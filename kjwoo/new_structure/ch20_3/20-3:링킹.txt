저장방식 지정자
    static

    thread_local

    extern

    mutable (이 녀석의 경우 저장 기간과 링크 방식에 영향을 주지는 않습니다.)

저장기간
자동 저장기간
여기에 해당하는 개체들은 {}안에 정의된 객체들로 코드블록을 빠져나가면 자동으로 소멸함.
static, extern, thread_local로 지정된 객체들 이외의 모든 지역객체들이 이 자동저장기간을 가짐
(흔히 말하는 지역변수)

static 저장 기간
static 저장 기간에 해당하는 개체들은 프로그램 시작시 할당되고 끝날때 소멸
static 객체들은 프로그램에서 유일하게 존재한다.
지역변수의 경우 만일 여러 쓰레드에서 같은 함수를 실행하면 지역변수의 복사본들이 여러군데 존재하지만
static객체는 이 경우에도 유일하게 존재함.

보통 함수 밖에 정의된 것이나 static 혹은 extern으로 정의된 객체들이 static저장기간을 갖는다.
static이 아니더라도 static 저장기간을 가질 수 있으니 주의

int a; // 전역변수 static저장기간
namespace ss{
    int b; //static 저장기간
}
extern int a; //static 저장기간
int func(){
    static int x; //static 저장기간. 
}

쓰레드 저장기간
쓰레드 저장기간에 해당하는 객체들은 쓰레드 시작시 할당되고, 쓰레드 종료시 소멸
thread_local로 선언된 객체들이 쓰레드 저장기간을 갖는다.
thread_local 객체들은 각 쓰레드들이 해당객체들의 복사본을 갖게됨. 
마치 전역변수처럼 정의돼있지만 실제로는 쓰레드에 하나씩 복사본을 갖게되고 
그 쓰레드 안에서 전역변수인 것 처럼 참조가됨.

동적 저장기간.
동적할당함수를 통해 할당되고 해제되는 객체들
new, delete로 정의되는 객체들.

링크방식
저장방식은 객체들에게만 해당되지만 링크방식은 객체,함수,클래스,템플릿,이름공간 등등 지칭이름들에 적용됨.

1.No linkage 방식
{}안에 정의된 이름들이 이 경우에 해당.
extern으로 지정되지 않는 이상 링크 방식이 지정되지않는 개체들의 경우 같은 스코프 내에서만 참조가 가능

2.Internal Linkage 방식
static으로 정의된 함수,변수,템플릿함수,템플릿변수들이 내부링크방식에 해당.
내부링크방식으로 정의된 것들은 같은 TU내에서만 참조가 가능. 그외 익명의 이름공간에 정의된 함수나
변수들 모두 내부링크방식
namespace {
int a;  // <- 내부 링크 방식
}
static int a;  // 이와 동일한 의미

3. external Linkage
외부링크방식으로 정의된 개체들은 다른TU에서도 참조 가능합니다.
참고로 외부 링크방식으로 정의된 개체들에 언어링크방식을 정의 할수도있어서
다른 언어사이에서 함수를 공유하는 것이 가능해집니다.
블록 스코프 안에 정의된 변수를 외부링크방식으로 선언하고싶다면 extern키워드를 사용하면된다.

extern "C" int func();  // C 및 C++ 에서 사용할 수 있는 함수.

// C++ 에서만 사용할 수 있는 함수. 기본적으로 C++ 의 모든 함수들에 extern "C++"
// 이 숨어 있다고 보시면 됩니다. 따라서 아래처럼 굳이 명시해줄 필요가 없습니다.
extern "C++" int func2();
int func2();  // 위와 동일

이름 맹글링
C에서 C++의 함수를 사용하기위해서는 extern "C"로 언어링크방식을 명시해줘야한다.
그 이유는 목적파일 생성시 C컴파일러가 함수이름을 변환하는 방식과 c++컴파일러가
함수이름을 변환하는 방식이 다르기 때문.
C의 경우 함수이름 변환 자체가 이뤄지지 않아서
int func(const char* s) {} 를 C컴파일러가 변환하면
$ nm a.out
0000000000000000 T func
c++ 컴파일러가 변환하면
$ nm a.out
0000000000000000 T _Z4funcPKc

함수이름이 변환된 것을 확인.
이것을 Name mangling이라고 하며 엉망진창으로 만들다라는 의미임.
이것은 c++에서는 같은이름의 함수를 정의할 수 있기 때문
오버로딩으로도 가능하고, 다른이름공간이어도 가능

이름 맹글링을하면 함수이름+이름공간+함수의인자 정보가 들어가게됨


링킹
이제야 진짜 링킹 가능.
각각의 TU들에서 생성된 목적코드들을 한데모아 하나의 실행파일을 만드는 작업.


재배치
정적링킹
동적링킹
