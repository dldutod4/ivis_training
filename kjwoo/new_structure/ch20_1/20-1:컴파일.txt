cpp의 컴파일과정

1. preprocessing :#include, #define 같은 전처리 매크로들을 처리하는 전처리단계

2. compile: 각각의 소스파일을 어셈블리 명령어로 변환하는 단계

3. Assemble: 어셈블리 코드들을 실제 기계어로 이루어진 목적코드(object file)로 변환하는 어셈블

4. Linking: 각각의 목적코드들을 한데 모아서 하나의 실행파일로 만들어주는 링킹단계

1.preprocessing

phase1 문자들 해석하기
c++에는 총 96개의 문자들로 이루어진 Basic source character set이 있다.
5종류의 공백문자
10종류의 숫자
29종류의 특수문자

이 기본문자 셋에 포함되지않은 문자들은 \u를 통해 유니코드로 치환되거나 컴파일러에 의해 따로 해석.

phase2 문자 해석
백슬래시 문자가 문장 맨끝에 위치하면 해당문장과 다음에 오는 문장이 하나로 합쳐지고 개행문자는 삭제됨

phase3 전처리 토큰들로 분리
소스를 주석, 공백, 전처리 토큰들로 분리.
전처리토큰 : 헤더이름, 식별자, 문자/문자열리터럴, 연산자
주석은 모두 공백문자 하나로 변경
컴파일러가 전처리기토큰을 인식할 때 가능한 가장 긴 전처리 토큰을 만드려함 (maximal munch)
int a = bar+++++baz; 라고 했을 때
int a = bar++ + ++baz라고 의도했어도
int a = bar++ ++ +baz로 해석되어 컴파일 오류가 발생.

int bar = 0xE+foo 도
int bar = 0xE + foo가 아니라
int bar = 0xE+ foo로 해석되어 오류 (부동소수점리터럴의 경우 E를 통해 지수를 지정할수있기때문.0xE+12)


phase4 전처리기 실행

     #include 에 지정된 파일의 내용을 복사합니다.

    #define 에 정의된 매크로를 사용해서 코드를 치환합니다.

    #if, #ifndef 와 같은 구문들을 실행해서 코드를 치환합니다.

    #pragma 와 같은 컴파일러 명령문들을 해석합니다. 

phase5
소스코드문자셋 -> 실행문자셋으로 변경

phase6 인접한 문자열 합치기

std::cout << "abc"
             "def";

std::cout << "abcdef";  로 변경

컴파일
phase7 해석유닛 생성
전처리기 토큰들이 컴파일 토큰으로 변환되어
컴파일 토큰들은 컴파일러에 의해 해석되어 해석 유닛을 생성한다.
해석유닛은 각 소스파일별로 하나씩 존재하게됨.

phase8 인스턴스 유닛 생성
생성된 TU를 분석해서 필요로하는 템플릿 인스턴스들을 확인.
템플릿들의 정의 위치가 확인되면 해당템플릿들의 인스턴스화 진행 - 인스턴스 유닛이 생성.

링킹
윈도우 -> portable Executable 생성 (exe)
리눅스 -> Executable and linkable format 생성(elf)


