//좌측값도 이동을 시키고 싶다면?
template <typename T>
void my_swap(T &a, T &b) {
  T tmp(a); //복사 1
  a = b; // 복사 2
  b = tmp; //복사 3
}
너무 비효율적

a가 좌측값이기 때문에 이동생성자는 호출되지않는다.

좌측값을 우측값으로 취급될 수 있게 바꿔주는 함수.
move함수


int main() {
  A a; //일반생성자

  std::cout << "---------" << std::endl;
  A b(a); //복사생성자

  std::cout << "---------" << std::endl;
  A c(std::move(a)); //이동생성자
}
move는 단순히 타입을 변환해준다.
MyString::MyString(MyString &&str) { //이동생성자
  std::cout << "이동 생성자 호출 !" << std::endl;
  string_length = str.string_length;
  string_content = str.string_content;
  memory_capacity = str.memory_capacity;

  // 임시 객체 소멸 시에 메모리를 해제하지
  // 못하게 한다.
  str.string_content = nullptr;
  str.string_length = 0;
  str.memory_capacity = 0;
}
MyString& MyString::operator=(MyString&& s) { //이동대입연산자
  std::cout << "이동!" << std::endl;
  string_content = s.string_content;
  memory_capacity = s.memory_capacity;
  string_length = s.string_length;

  s.string_content = nullptr;
  s.memory_capacity = 0;
  s.string_length = 0;
  return *this;
}
template <typename T>
void my_swap(T &a, T &b) {
  T tmp(std::move(a)); //이동 생성
  a = std::move(b); //이동 대입
  b = std::move(tmp);//이동 대입

}

기존의 A객체를 그대로 넣어 B를 생성하고 싶을 때

#include <iostream>

class A {
 public:
  A() { std::cout << "ctor\n"; }
  A(const A& a) { std::cout << "copy ctor\n"; }
  A(A&& a) { std::cout << "move ctor\n"; }
};

class B {
 public:
  B(A&& a) : a_(std::move(a)) {}

  A a_;
};

int main() {
  A a;
  std::cout << "create B-- \n";
  B b(std::move(a));
}

완벽한 전달 (perfect forwarding)
template <typename T>
void wrapper(T u) {
  g(u);
}
g(u)로 바로 정의해서 호출하면되는데 왜쓰는건가
vector에도 emplace_back이라는 같은방식으로 인자를 전달하는 함수가 있다.

vec.push_back(A(1, 2, 3)); 이 경우 A객체를 생성후 인자로 전달하여 불필요한 이동, 복사가 발생
vec.emplace_back(1, 2, 3);  //내부에서 a의 생성자를 호출한 뒤 벡터원소에 추가함.

이론상 push_Back보다 emplace_back이 불필요한 이동 복사를 안하지만
사실 push_back도 컴파일러가 알아서 최적화를해주기때문에 push_back을 쓰는게 더 안정적이다.

template <typename T>
void wrapper(T u) {
  g(u);
}
void g(A& a) { std::cout << "좌측값 레퍼런스 호출" << std::endl; }
void g(const A& a) { std::cout << "좌측값 상수 레퍼런스 호출" << std::endl; }
void g(A&& a) { std::cout << "우측값 레퍼런스 호출" << std::endl; }

이있을때 g의 인자로 어떤값을 넣든 좌측값레퍼런스만 호출된다.
그 이유는 위의 템플릿에서 인자 T u의 타입을 추론할때 T가 레퍼런스가 아닌 일반타입이면 const를 무시하기때문이다.
즉 전부 class A로 추론된다.54

template <typename T>
void wrapper(T& u) {
  g(u);
}
위와같이 레퍼런스를 명시하면 const는 적용되지만
g(A()); 에서 에러가 발생한다.
우측값인 A()의 리턴값을 레퍼런스 T&가 레퍼런스할 수 없기때문이다.
그래서 우측값을 받을수 있는 const A&도 따로 만들어줘야한다.
void wrapper(T& u) {
  std::cout << "T& 로 추론됨" << std::endl;
  g(u);
}

template <typename T>
void wrapper(const T& u) {
  std::cout << "const T& 로 추론됨" << std::endl;
  g(u);
}

class A {};

void g(A& a) { std::cout << "좌측값 레퍼런스 호출" << std::endl; }
void g(const A& a) { std::cout << "좌측값 상수 레퍼런스 호출" << std::endl; }
void g(A&& a) { std::cout << "우측값 레퍼런스 호출" << std::endl; }

이렇게해도 우측값 레퍼런스가 호출되지않는다.
wrapper안의 u가 좌측값이기때문에 그렇다
그리고 만약 인자가 하나가 아니라 2개를 받는다면 모든 조합의 템플릿 함수를 정의해야한다.

보편적 레퍼런스
template <typename T>
void wrapper(T&& u) {
  g(std::forward<T>(u));
}
템플릿 T에 대해서 우측값 레퍼런스를 받는 형태를 보편적 레퍼런스라고하며
우측값만 받는 레퍼런스와는 다르다.

int&&와 같은 우측값레퍼런스와는 달리 템플릿에서의 T&& 보편적레퍼런스는 좌측값과 우측값을 둘다 받으며
레퍼런스 겹침 규칙에 따라 T의 타입을 추론합니다.

typedef int& T;
T& r1;   // int& &; r1 은 int&
T&& r2;  // int & &&;  r2 는 int&

typedef int&& U;
U& r3;   // int && &; r3 는 int&
U&& r4;  // int && &&; r4 는 int&&

&는 1 &&는 0으로 보고 or연산한다고 생각하면 쉽다.

g(u)일때
u가 우측값 레퍼런스일때만 move를 해줘야 한다.
좌측값일때 move를 해버리면 우측값에 오버로딩된 g가 호출된다.
그래서 forward함수를 써야한다.
forward<T>함수는 우측값레퍼런스일때만 move를 적용한 것처럼 작동한다.
