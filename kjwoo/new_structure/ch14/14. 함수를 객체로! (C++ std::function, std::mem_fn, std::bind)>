    Callable 의 정의

    std::function

    std::mem_fn

    std::bind


    Callable
 c++에서는 ()를 붙여 호출할 수 있는 모든 것을 의미합니다.

 함수, 함수객체,람다함수
auto f = [](int a, int b) { std::cout << "a + b = " << a + b << std::endl; };
f(3, 5);

f역시 Callable이다.

Callable을 객체의 형태로 보관할 수 있는 std::function클래스를 제공함.
함수 뿐아니라 모든 calable들을 보관할 수 있음.
std::function<int(const string&)> f1 = some_func1;
std::function<void(char)> f2 = S(); //함수객체의 객체를 전달.
std::function<void()> f3 = []() { std::cout << "Func3 호출! " << std::endl; };

std::function(리턴(인자값)) f1 = some_func1 ,s(),[]()->{std::cout << "hello"}

멤버함수를 갖는 경우는 조금다른데 this가 무엇인지 알 수 없게되기 때문이다.

#include <functional>
#include <iostream>
#include <string>

class A {
  int c;

 public:
  A(int c) : c(c) {}
  int some_func() { std::cout << "내부 데이터 : " << c << std::endl; }
};

int main() {
  A a(5);
  std::function<int()> f1 = a.some_func;
}

std::function<int()> f1 = a.some_func;
error: invalid use of non-static member function 'int A::some_func()'

멤버함수들은 암묵적으로 자신을 호출한 객체를 인자로 받고있다.

class A {
  int c;

 public:
  A(int c) : c(c) {}
  int some_func() {
    std::cout << "비상수 함수: " << ++c << std::endl;
    return c;
  }

  int some_const_function() const {
    std::cout << "상수 함수: " << c << std::endl;
    return c;
  }

  std::function<int(A&)> f1 = &A::some_func;
  std::function<int(const A&)> f2 = &A::some_const_function;

std::function<리턴((상수함수면 const)클래스&) f1 = &클래스::member_func;
멤버함수들의 경우 암시적 변환이 발생하지않아 & 연산자를 통해 명시적으로 주소를 전달해줘야함.
f1(a), f2(a)


mem_fn
멤버함수들을 함수객체로 바꾼다.
std::transform(container.begin(), container.end(), size_vec.begin(), &vector<int>::size);
위 함수는 container 벡터에 들은 벡터들의 사이즈를 구해 size_vec에 넣는 목적이다.

그러나 transform 함수의 원형은.
template <class InputIt, class OutputIt, class UnaryOperation>
OutputIt transform(InputIt first1, InputIt last1, OutputIt d_first,
                   UnaryOperation unary_op) {
  while (first1 != last1) {
    *d_first++ = unary_op(*first1);
    first1++;
  }
  return d_first;
}
인데
*d_first++ = unary_op(*first1); 에서
&vector<int>::size가 들어가는 unary_op(*first1)이 문제이다.
&vector<int>::size(*first)의 형태지만
first->*&vector<int>::size 의 형태로 호출해야하기 때문이다.

이것을 std::function으로 바꿔 넣는다
std::function<int(const vector<int>&)> func1 = &vector<int>::size;
std::transform(container.begin(),container.end(),size_vec.beigin(),func1);

이렇게하면 func1(*first1)의 형태이므로 *first1의 멤버함수로서 호출이 가능하다. //first는 iterator이므로 *first는 벡터가 된다.


그런데 이런식으로 function객체 선언하는 것이 번거로우므로
mem_fn을 사용한다.
std::mem_fn(&vector<int>::size);

그런데 mem_fn도 굳이 쓸필요 없다
람다함수로 넣으면 되기 때문이다.
[](const auto& v){return v.size()}도 똑같이 작동한다.

std::bind
함수객체를 생설할때 인자를 지정할 수 있다.

#include <functional>
#include <iostream>

void add(int x, int y) {
  std::cout << x << " + " << y << " = " << x + y << std::endl;
}

void subtract(int x, int y) {
  std::cout << x << " - " << y << " = " << x - y << std::endl;
}
int main() {
  auto add_with_2 = std::bind(add, 2, std::placeholders::_1); 
  //첫번째인자가 2로 bind되고 placeholders는 add_with_2의 첫째 인자가 들어간다.
  add_with_2(3);

  // 두 번째 인자는 무시된다.
  add_with_2(3, 4);

  auto subtract_from_2 = std::bind(subtract, std::placeholders::_1, 2);
  auto negate =
      std::bind(subtract, std::placeholders::_2, std::placeholders::_1);

  subtract_from_2(3);  // 3 - 2 를 계산한다.
  negate(4, 2);        // 2 - 4 를 계산한다
}
void subtract(int x, int y) {
  std::cout << x << " - " << y << " = " << x - y << std::endl;
}
auto negate = std::bind(subtract, std::placeholders::_2, std::placeholders::_1);
첫째 인자와 둘째 인자의 순서를 바꿔준다
placeholder는 _1,_2 .. 일일히 정의된 객체로 라이브러리마다 갯수가 다르다

단 레퍼런스를 인자로 받는 함수들을 주의
  void do_something(S& s1, const S& s2) { s1.data = s2.data + 3; }

  auto do_something_with_s1 = std::bind(do_something, s1, std::placeholders::_1);
  do_something_with_s1(s2);


이때 s1이 bind함수에 복사되어 들어가기때문에 수정해도 반영되지않는다. 레퍼런스를 직접 넣어줘야한다.
  auto do_something_with_s1 =
      std::bind(do_something, std::ref(s1), std::placeholders::_1);
로 바꿔야한다.
ref함수는 전달받은 인자를 복사 가능한 레퍼런스로 변환해준다.
constant 레퍼런스는 cref로 변환한다.
