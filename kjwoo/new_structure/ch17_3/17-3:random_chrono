<random> 라이브러리를 활용한 난수 생성\

c의 random에는 문제점들이 있다
시드값이 너무 천천히 변한다.
0 부터 99 까지 균등하게 난수를 생성하지 않는다. 0~Rand_MAX까지 같은확률이지만 100으로 나눈나머지는 다르다.
rand() 자체도 별로 뛰어나지 않다. -> 난수열들의 상관관계까 높다.

C++ 에서는 C 의 srand 와 rand 는 갖다 버리자!
<random>
#include <iostream>
#include <random>

int main() {
  // 시드값을 얻기 위한 random_device 생성.
  std::random_device rd;

  // random_device 를 통해 난수 생성 엔진을 초기화 한다.
  std::mt19937 gen(rd());

  // 0 부터 99 까지 균등하게 나타나는 난수열을 생성하기 위해 균등 분포 정의.
  std::uniform_int_distribution<int> dis(0, 99);

  for (int i = 0; i < 5; i++) {
    std::cout << "난수 : " << dis(gen) << std::endl;
  }
}

양질의 시드값을 얻기위해 random_device를 사용한다.
장치 드라이버들의 noise와 같은 무작위 요소를 기반으로한 난수를 제공함
난수 생성속도가 매우느림.
난수엔진을 초기화하는데에만 사용하고 난수열은 난수엔진으로 생성함.

// random_device 를 통해 난수 생성 엔진을 초기화 한다.
std::mt19937 gen(rd());
std::mt19937 는 C++ <random> 라이브러리에서 제공하는 난수 생성 엔진
메르센 트위스터 라는 알고리즘
난수들 간의 상관관계가 매우 작기 때문에 여러 시뮬레이션에서 사용
난수를 생성하기에는 적합하지만 생각보다 객체 크기가 커서 (2KB 이상) 
메모리가 부족한 시스템에서는 오히려 minstd_rand 가 적합

C++ 의 경우 어디에서 수들을 뽑아낼지 알려주는 분포(distribution) 을 정의
std::uniform_int_distribution<int> dis(0, 99);
for (int i = 0; i < 5; i++) {
  std::cout << "난수 : " << dis(gen) << std::endl;
}

<chrono>
3 가지 요소들로 구성되어 있습니다.

현재 시간을 알려주는 시계 - 예를 들어서 system_clock
특정 시간을 나타내는 time_stamp
시간의 간격을 나타내는 duration

std::system_clock =일반적 시계
std::high_resolution_clock =  보다 정밀한 시계
지정된 시점으로 부터 몇 번의 틱(tick)이 발생 하였는지 알려주는 time_stamp 객체 를 리턴
std::system_clock 의 경우 1970 년 1월 1일 부터 현재 까지  = UNIX타임

time_stamp 객체는 clock 의 시작점과 현재 시간의 duration 을 보관하는 객체 


#include <chrono>
#include <iomanip>
#include <iostream>
#include <random>
#include <vector>

int main() {
  std::random_device rd;
  std::mt19937 gen(rd());

  std::uniform_int_distribution<> dist(0, 1000);

  for (int total = 1; total <= 1000000; total *= 10) {
    std::vector<int> random_numbers;
    random_numbers.reserve(total);

    std::chrono::time_point<std::chrono::high_resolution_clock> start =
        std::chrono::high_resolution_clock::now();

    for (int i = 0; i < total; i++) {
      random_numbers.push_back(dist(gen));
    }

    std::chrono::time_point<std::chrono::high_resolution_clock> end =
        std::chrono::high_resolution_clock::now();

    // C++ 17 이전
    auto diff = end - start;

    // C++ 17 이후
    // std::chrono::duration diff = end - start; 

    std::cout << std::setw(7) << total
              << "개 난수 생성 시 틱 횟수 : " << diff.count() << std::endl;
  }
}
clock 에는 현재의 time_point 를 리턴하는 static 함수인 now 가 정의
now() 를 호출하면 위와 같이 해당 clock 에 맞는 time_point 객체를 리턴
high_resolution_clock::now() 를 호출하였으므로, std::chrono::time_point<ch::high_resolution_clock> 를 리턴
와 같이 두 time_stamp 를 빼게 된다면 duration 객체를 리턴
duration.count()로 틱수를 알아낼 수 있다.
제 시간으로 얼마나 걸렸는지 알아내는 것 이를 위해선 duration_cast

ch::duration_cast<ch::microseconds>(diff).count()
<chrono> 에는 std::chrono::microseconds 외에도 nanoseconds, milliseconds, seconds, minutes, hours 가 정의

날짜
#include <chrono>
#include <ctime>
#include <iomanip>
#include <iostream>

int main() {
  auto now = std::chrono::system_clock::now();
  std::time_t t = std::chrono::system_clock::to_time_t(now);
  std::cout << "현재 시간은 : " << std::put_time(std::localtime(&t), "%F %T %z")
            << '\n';
}
system_clock 에서 현재의 time_point 를 얻어온 후에, 날짜를 출력하기 위해서 time_t 객체로 변환해야 합니다.
 clock 이 제공하는 static 함수인 to_time_t

C++ 20 부터 <chrono> 에 C 라이브러리 필요 없이 날짜를 다룰 수 있는 클래스와 함수들이 추가

