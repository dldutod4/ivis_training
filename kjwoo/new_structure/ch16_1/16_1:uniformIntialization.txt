균일한 초기화(Uniform initialization)

    class A {
public:
    A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
    A a();  // ?
}

위의 코드는 생성자를 호출하는게 아니라 A를 반환하는 인자가 없는 a함수를 정의한 것이 된다.

    class A {
public:
    A() { std::cout << "A 의 생성자 호출!" << std::endl; }
};

class B {
public:
    B(A a) { std::cout << "B 의 생성자 호출!" << std::endl; }
};

int main() {
    B b(A());  // 뭐가 출력될까요?
}
위의 코드 역시 인자로 A를 리턴하고 인자가 없는 함수를 받으며 리턴 타입이 B인 함수 b를 정의한것.

    () 가 객체생성에도 쓰이지만 함수의 인자를 정의하는데도 쓰이기 때문

    따라서 균일한 초기화를 도입 생성자 호출할때() 대신 {}
를 쓰면 끝.

    int
    main() {
    A a{};  // 균일한 초기화!
}

그러나 일부 암시적 타입변환들을 불허 하고있다.

    class A {
public:
    A(int x) { std::cout << "A 의 생성자 호출!" << std::endl; }
};

int main() {
    A a(3.5);  // Narrow-conversion 가능
    A b{3.5};  // Narrow-conversion 불가
}

초기화자 리스트 int arr[] = {1, 2, 3, 4};
vector<int> v = {1, 2, 3, 4};
도 가능

    데이터 손실이 있는 narrow conversio가 불가능 해진다.

    class A {
public:
    A(std::initializer_list<int> l) {  // 초기화자 리스트를 받아서
        for (auto itr = l.begin(); itr != l.end(); ++itr) {
            std::cout << *itr << std::endl;  // 하나씩 출력해주는 생성자.
        }
    }
};

int main() { A a = {1, 2, 3, 4}; }

map도 편하게 가능하다

    std::map<std::string, int>
        v = {1, 2, 3, 4, 5};
print_vec(v);

std::cout << "---------------------" << std::endl;
std::map<std::string, int> m = {{"abc", 1}, {"hi", 3}} pair의 원소들을 초기화자 리스트의 원소들로 받아준다.

                               주의할 점은 {}
로 객체를 생성할 경우 생성자 오버로딩 시에 해당 함수가 최우선으로 고려된다
    .

    vector
    v(10) 의 경우는 원래 10개의 공간을 미리 만들어두는 생성자가 실행됐지만 vector v{10} 은
    10을 보관하고 있는 벡터를 생성한다.

    class A {
public:
    A(int x, double y) { std::cout << "일반 생성자! " << std::endl; }

    A(std::initializer_list<int> lst) { std::cout << "초기화자 사용 생성자! " << std::endl; }
};

int main() {
    A a(3, 1.5);  // Good
    A b{3, 1.5};  // Bad! //암시적 변환이 불가능한데도 initializer_list<int> 생성자와 매칭해버린다.
}

{}
를 이용해 생성할 때 auto로 타입을 받으면 initializer_list 객체를 생성한다.auto a = {1};  // std::initializer_list<int>
auto b{1};                                                                               // std::initializer_list<int>
auto c = {1, 2};                                                                         // std::initializer_list<int>
auto d{1, 2};                                                                            // std::initializer_list<int>

비상식적이기 때문에 c++ 17부터 두가지 형태로 구분한다.

    auto x = {arg1, arg2...} 형태의 경우 arg1,
         arg2... 들이 모두 같은 타입이라면 x 는 std::initializer_list<T> 로 추론됩니다.

         auto x{arg1, arg2, ...} 형태의 경우 만일 인자가 단 1 개라면 인자의 타입으로 추론되고,
         여러 개일 경우 오류를 발생시킵니다.

         auto list = {"a", "b", "cc"};
list 는 initializer_list<std::string> 이 아닌 initializer_list<const char*> 이 된다

    using namespace std::literals;  // 문자열 리터럴 연산자를 사용하기 위해
                                    // 추가해줘야함.
auto list = {"a"s, "b"s, "c"s};
와 같이 하면, initializer_list<std::string> 으로 추론