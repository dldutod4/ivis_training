메모리 ram
ram에서 불러오는 것은 느리다 인텔 i7cpu의 경우 최소 42사이클

캐시
코어별로
L1 - L2 가 있고
모든코어가 공유하는 L3캐시가 존재한다.
L1 = 4사이클
L2 = 12사이클
L3 = 36사이클 정도 걸린다.

컴파일러는 최대한 cpu의 파이프 라인을 효율적으로 활용하도록 명령어를 재배치한다.
최종결과물은 달라지지않도록하지만 문제는 다른 쓰레드를 고려하지 않는다는 점이다.

c++의 모든 객체는 수정순서를 정의할 수 있다.

c++에서 보장하는 것은 원자적 연산을 할 경우에
모든 쓰레드에서 같은 객체에 대해 동일한 수정 순서를 관찰할 수 있다는 것.

예를들어 스레드가 T1~T3가 있고 a라는 변수가 있을때
T1: a = 5
T2: a = 8
T3: a = 6
T1: a = 3
의 수정순서에 모든 스레드가 동의하면

만약 어떤 스레드가 a=8인 것을 관찰했었다면 다음에 읽었을 때 a는 8 6 3중 하나이고 5일 수는 없다는 것만 보장.
심지어 a=8를 관측했던 두 스레드가 같은 시간에 a를 읽어도 한쪽은 8이고 다른쪽은 3일 수 있다.
그 이유는 각 코어별로 캐시가 존재하기 때문이다.
한 스레드가 자신의 캐시에서 a=8을 해놓는다면 다른 스레드에서는 이것을 모른다.
값을 기록할때마다 모든 캐시를 동기화할수 있겠지만 시간이 많이 걸린다.

원자성
모든 연산들이 원자적일 때 모든스레드들이 수정순서에 동의해야한다.
다시말해 원자적연산이 아니라면 모든 스레드가 같은 수정순서를 갖는다는 것도 보장이 안되기때문에 직접 동기화를 해야한다.
원자적 연산이란 그 연산을 하는중 다른 스레드가 끼어들 수 없는 연산을 뜻함.

몇몇타입들에 대해 원자적 연산을 지원하고있음
뮤텍스가 필요하지않아 더 빠르다.

void worker(std::atomic<int>& counter) {
  for (int i = 0; i < 10000; i++) {
    counter++;
  }
}
counter에 대해 연산하는 것에 원자성을 보장한다.

atomic
std::atomic<int> counter(0);
int를 원자적으로 만든 타입. 원자적 연산을 지원하게한다.
counter++를 예를들면
lock add DWORD PTR [rdi], 1
한줄로 컴파일되어 원자성이 보장된다.
lock add 는 읽고 더하고 다시 쓰고 를 한번에 해버림

해당 객체의 연산이 정말 원자적으로 구현될 수 있는지는 is_lock_free()함수를 호출해보면
true, false로 알 수 있음. lock없이도 해당 연산을 올바르게 수행할 수 있냐는 의미

memory_order
atomic 객체들이 원자적 연산 시 메모리에 접근할때 접근 방식을 지정할 수 있음

memory_order_relexed
가장 느슨한 조건
주위의 다른 메모리 접근들과 순서가 바뀌어도 무방함.

void t1(std::atomic<int>* a, std::atomic<int>* b) {
  b->store(1, memory_order_relaxed);      // b = 1 (쓰기)
  int x = a->load(memory_order_relaxed);  // x = a (읽기)

  printf("x : %d \n", x);
}

void t2(std::atomic<int>* a, std::atomic<int>* b) {
  a->store(1, memory_order_relaxed);      // a = 1 (쓰기)
  int y = b->load(memory_order_relaxed);  // y = b (읽기)

  printf("y : %d \n", y);
}

x:0
y:0을 관찰할 수 있을까
t1:
b=1
x=a

t2:
a=1
y=b

일때 만약 t1의 순서가 재배치되어
t1:
x=a 
b=1

t2:
a=1
y=b
가 되었다면

t1:x=a
t2:a=1
t2:y=b
t1:b=1
로 실행되어 
x:0, y:0이 출력 될 수 있다.

memory_order_relax는 연산수행에 있어 자유로운 순서배치를 하여
빠르지만 순서에 대한 제약이 없다.

memory_order_acquire 과 memory_order_release
relaxed는 자유도가 너무커서 사용이 제한적이다.

memory_order_release
해당 명령뒤에 다른 메모리 접근 명령이 재배치되는 것을 금지함.
즉 위의 경우에서 memory_order_release로 x=a명령을 했다면 b=1이 x=a뒤에 재배치되는 것이 금지되고
x:0 y:0이 나올 수 없었을 것이다.

memory_order_acquire
해당 명령 뒤의 모든 메모리 명령들이 해당 명령 위로 재배치되는 것을 금지.
이 경우 b=1을 memory_order_acquire로 명령했으면 x=a가 b=1위로 올라오지 못해
x:0, y:0이 나오지 못했을 것이다.

memory_order_acq_rel
위의 두가지를 모두 수행함.

memory_order_seq_cst
순차적 일관성을 보장함.
해당 메모리 명령들 사이에서는 메모리 명령 재배치를 하지 않는것.
따로 지정하지않으면 이것이 디폴트이다.
문제는 꽤나 비싼 연산이라는 것.
intel이나 amd 경우에는 거의 순차적일관성이 보장되서 큰 차이없지만
arm계열에서는 동기화비용이 매우 커서 꼭 필요한 경우에만 사용해야함.







