std::optional

    std::variant

        std::tuple
#include <iostream>
#include <map>
#include <string>

            std::pair<std::string, bool>
            GetValueFromMap(const std::map<int, std::string>& m, int key) {
    auto itr = m.find(key);
    if (itr != m.end()) {
        return std::make_pair(itr->second, true);
    }

    return std::make_pair(std::string(), false);
}

int main() {
    std::map<int, std::string> data = {{1, "hi"}, {2, "hello"}, {3, "hiroo"}};
    std::cout << "맵에서 2 에 대응되는 값은? " << GetValueFromMap(data, 2).first << std::endl;
    std::cout << "맵에 4 는 존재하나요 " << std::boolalpha << GetValueFromMap(data, 4).second << std::endl;
}

맵에 키가 존재 하지 않을 때 디폴트 객체를 리턴해야 한다는 점 객체의 디폴트 생성자가 정의되어 있지 않을 수 도 있고

    객체를 디폴트 생성하는 것이 매우 오래 걸릴 수 도 있다 원하는 값을 보관할 수 도,
    안할 수 도 있는 클래스 를 도입

        std::optional
#include <iostream>
#include <map>
#include <string>
#include <utility>

            std::optional<std::string>
            GetValueFromMap(const std::map<int, std::string>& m, int key) {
    auto itr = m.find(key);
    if (itr != m.end()) {
        return itr->second;
    }

    // nullopt 는 <optional> 에 정의된 객체로 비어있는 optional 을 의미한다.
    return std::nullopt;
}

int main() {
    std::map<int, std::string> data = {{1, "hi"}, {2, "hello"}, {3, "hiroo"}};
    std::cout << "맵에서 2 에 대응되는 값은? " << GetValueFromMap(data, 2).value() << std::endl;
    std::cout << "맵에 4 는 존재하나요 " << std::boolalpha << GetValueFromMap(data, 4).has_value() << std::endl;
}

std::optional<std::string> 템플릿 인자로 optional 이 보관하고자 하는 객체의 타입 GetValueFromMap 함수 안에서 키에
    대응하는 값이 존재한다면 그냥 해당 값을 리턴 std::optional 에는 보관하고자 하는 타입을 받는 생성자가 정의되어 있기
        때문에 위와 같이 그냥 리턴하더라도 optional 객체로 알아서 만들어져서 리턴

            optional 의 가장 큰 장점으로,
    객체를 보관하는 과정에서 동적 할당이 발생하지 않는다 따라서 불필요한 오버헤드가
        없다.std::nullopt 는 미리 정의되어 있는 빈 optional 객체를 나타냅니다
            .optional 객체가 가지고 있는 객체를 접근하고 싶다면
            value() 함수를 호출 드시 optional 가 들고 있는 객체에 접근하기 전에 실제로 값을 가지고 있는지 확인
    GetValueFromMap(data, 4)
            .has_value() value() 함수 대신에 역참조 연산자를(*) 이용하셔도 됩니다.GetValueFromMap(data, 2)
            .value() 와 *GetValueFromMap(data, 2) 는 동일 pair 와는 달리 아무 것도 들고 있지 않는
    상태에서 디폴트 객체를 가질 필요가 없다

    레퍼런스를 가지는 std::optional std::optional 의 한 가지 단점으로는 일반적인 방법으로는 레퍼런스를 포함할 수 없다
    std::reference_wrapper 를 사용해서 레퍼런스 처럼 동작하는 wrapper 객체를 정의 std::reference_wrapper 는
    레퍼런스가 아니라 일반적인 객체이기 때문에 optional 에 전달할 수 있습니다.reference_wrapper 를
    get() 함수를 통해서 레퍼런스 하고 있는 객체를 얻어

    std::optional<std::reference_wrapper<A>> maybe_a = std::ref(a);
대신 reference_wrapper 객체를 생성하기 위해서는 std::ref 함수를
        사용->연산자 역시 정의되어 있어서 가지고 있는 값에 함수를 호출할 수 있습니다.

    std::variant(C++ 17 이상 - <variant>) std::variant 는 one
    - of 를 구현한 클래스 variant 를 정의할 때 포함하고자 하는 타입들을 명시해줘야 합니다.
      // v 는 이제 int
      std::variant<int, std::string, double> v = 1;

// v 는 이제 std::string
v = "abc";

// v는 이제 double
v = 3.14;

컴파일 타임에 정해진 여러가지 타입들 중에 한 가지 타입의 객체를 보관할 수 있는 클래스 variant 의 가장 큰 특징으로는
    반드시 값을 들고 있어야 한다 std::variant<int, std::string, double>
        v;  // 첫 번째 타입 인자 (int) 의 디폴트 생성자가 호출
optional 과 비슷하게 객체의 대입 시에 어떠한 동적 할당도 발생하지 않습니다

    variant 객체 자체의 크기는 나열된 가능한 타입들 중 가장 큰 타입의 크기를 따라갑니다.

    std::variant<A, B>
    GetDataFromDB(bool is_a) {
    if (is_a) {
        return A();
    }
    return B();
}

int main() {
    auto v = GetDataFromDB(true);

    std::cout << v.index() << std::endl;
    std::get<A>(v).a();  // 혹은 std::get<0>(v).a()
}

variant 에 몇 번째 타입이 들어있는지 알고 싶다면 index() 함수를 사용 실제로 원하는 값을 뽑아내고 싶다면 외부에
    정의되어 있는 함수인 std::get<T> 를 이용 T는뽑고자하는 타입이거나 인덱스

    std::monostate variant 에 아무 것도 들고 있지 않은 상태를 표현하고자 싶다면 해당
    타입으로 std::monostate 를 사용 이를 통해서 마치 std::optional 과 같은 효과

    variant 안에 정의된 타입들 중에 디폴트 생성자가 있는 타입이 하나도 없는 경우 역시 std::monostate 를 활용 첫 번째
    타입으로 std::monostate 를 지정해주면 깔끔

    여러 서로 다른 타입들의 묶음을 간단하게 다룰 수 있도록 제공하는 std::tuple C
    ++ 11 부터 std::tuple 라이브러리가 추가되어서 간단히 서로 다른 타입들의 집합을 생성

    tuple 을 정의하는 방법은 간단합니다
        .tuple 이 보관하고자 하는 타입들을 쭈르륵 나열 variant 와는 다르게 tuple 에는 같은
    타입들이 들어 있어도 전혀 문제가 될 것이 없습니다.선언 std::tuple<int, double, std::string> tp;
tp = std::make_tuple(1, 3.14, "hi");

원소 접근 std::cout << std::get<0>(tp) << ", " << std::get<1>(tp) << ", " << std::get<2>(tp) << std::endl;
타입지정시 같은타입 2 개 이상 존재한다면 예외가 발생

#include <iostream>
#include <string>
#include <tuple>

        std::tuple<int, std::string, bool> GetStudent(int id) {
    if (id == 0) {
        return std::make_tuple(30, "철수", true);
    } else {
        return std::make_tuple(28, "영희", false);
    }
}

int main() {
    auto student = GetStudent(1);

    int age = std::get<0>(student);
    std::string name = std::get<1>(student);
    bool is_male = std::get<2>(student);

    std::cout << "이름 : " << name << std::endl;
    std::cout << "나이 : " << age << std::endl;
    std::cout << "남자 ? " << std::boolalpha << is_male << std::endl;
}


    Structured binding(C++ 17 이상)

    #include <iostream>
#include <string>
#include <tuple>

std::tuple<int, std::string, bool> GetStudent(int id) {
  if (id == 0) {
    return std::make_tuple(30, "철수", true);
  } else {
    return std::make_tuple(28, "영희", false);
  }
}

int main() {
  auto student = GetStudent(1);

  auto [age, name, is_male] = student;

  std::cout << "이름 : " << name << std::endl;
  std::cout << "나이 : " << age << std::endl;
  std::cout << "남자 ? " << std::boolalpha << is_male << std::endl;
}


auto [age, name, is_male] = student;
auto /* & 혹은 && 도 가능 */ [/* tuple 안에 원소들을 받기 위한 객체*/] = tp;

tuple 안에 객체들을 복사하지 않고 그냥 레퍼런스만 취하기
auto& [age, name, is_male] = student;

한 가지 중요한 점은 tuple 의 모든 원소들을 반드시 받아야 한다는 점
