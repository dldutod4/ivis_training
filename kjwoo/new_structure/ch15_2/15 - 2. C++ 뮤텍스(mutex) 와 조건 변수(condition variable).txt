Race Condition
서로 다른 쓰레드들이 동일한 자원을 사용할 때

counter += 1은 다음과 같은 어셈블리 코드로 컴파일된다.
mov rax, qword ptr [rbp - 8] //8바이트주소 rbp-8에 있는 값을 rax에 가져온다
mov ecx, dword ptr [rax]  //ecx에 rax주소에 있는 값을 가져옴
add ecx, 1 //ecx++
mov dword ptr [rax], ecx //ecx값을 rax주소에 저장

만약 2번째줄에서 스위칭되어 컨텍스트 스위칭되어 똑같은 명령이 실행되고
rax에 ecx가 +1 되어 저장되었어도
다시 되돌아가 3번째줄부터 실행하면 ecx에 가져온 값은 스위칭 전과 같으므로 다시 ecx+1을 저장
하여 결국 이전의 연산이 덮어 씌워져 한번만 적용된다.

멀티쓰레드 프로그램은 디버깅이 매우 어렵다.

mutex
한번에 한 스레드에서만 해당 코드를 실행시키게 해주는 객체
mutual exclusion 상호배제

std::mutex m;
m.lock(); //m의 사용권한을 얻는 것
m.unlock(); //사용권한을 반환

m의 사용권한을 얻지 못한 코드는 m.lock()을 만나면 무한정 대기
Critical Section
한 스레드만 유일하게 실행 가능한 코드 부분을 의미

만약 unlock을 하지 않는다면 자신을 제외한 스레드들이 lock에서 멈추게되고
 자신또한 반복문을 거쳐 다시 lock을만나 연산이 불가능해진다.

뮤텍스 객체 역시 unique_ptr처럼 사용후 소멸자에서 처리하면 unlock을 신경쓰지않아도된다.
lock_guard를 통해 해결한다.
lock_guard<std::mutex> lock(m);

lock_guard인자는 뮤텍스 객체를 인자로 받아 뮤텍스를 lock하고 소멸할때 뮤텍스를 unlock해준다.


void worker(int& result, std::mutex& m) {
  for (int i = 0; i < 10000; i++) {
    // lock 생성 시에 m.lock() 을 실행한다고 보면 된다.
    std::lock_guard<std::mutex> lock(m);
    result += 1;

    // scope 를 빠져 나가면 lock 이 소멸되면서
    // m 을 알아서 unlock 한다.
  }
}

데드락 deadlock

void worker1(std::mutex& m1, std::mutex& m2) {
    for (int i = 0; i < 10000; i++) {
        std::lock_guard<std::mutex> lock1(m1);
        std::lock_guard<std::mutex> lock2(m2);
        // Do something
    }
}

void worker2(std::mutex& m1, std::mutex& m2) {
    for (int i = 0; i < 10000; i++) {
        std::lock_guard<std::mutex> lock2(m2);
        std::lock_guard<std::mutex> lock1(m1);
        // Do something
    }
}

worker1이 m1을 갖고 worker2가 m2를 갖고있으면 서로의 뮤텍스를 기다리게 되면서
deadlock에 빠지게 됨.

해결방법 중 하나는 한 스레드에 우선순위를 주는 것이다.
void worker1(std::mutex& m1, std::mutex& m2) {
  for (int i = 0; i < 10; i++) {
    m1.lock();
    m2.lock();
    std::cout << "Worker1 Hi! " << i << std::endl;

    m2.unlock();
    m1.unlock();
  }
}

void worker2(std::mutex& m1, std::mutex& m2) {
  for (int i = 0; i < 10; i++) {
    while (true) {
      m2.lock();

      // m1 이 이미 lock 되어 있다면 "야 차 빼" 를 수행하게 된다.
      if (!m1.try_lock()) {
        m2.unlock(); //worker1이 m2의 unlock을 기다리고 있었으면 m2를 lock할 것이다.
        continue;
      }

      std::cout << "Worker2 Hi! " << i << std::endl;
      m1.unlock();
      m2.unlock();
      break;
    }
  }
}

try_lock 함수는 lock을 할 수있다면 lock을 하고 true를 리턴
할 수 없다면 false를 리턴합니다.

데드락을 피하는 가이드
중첩된 lock사용을 피한다.
lock소유할때 유저코드 호출을 피한다.
lock들은 언제나 정해진 순서로 획득한다.

생산자와 소비자 패턴
생산자의 경우 처리할 일을 받아오는 쓰레드
소비자는 받은일을 처리하는 쓰레드

producer가 task을 큐에 넣고 consumer가 큐에 있는 task을 처리하는 방식
producer도 consumer도 복수이다.
consumer는 큐가 비어있으면 대기 해야한다.

m->lock();
// 만일 현재 다운로드한 페이지가 없다면 다시 대기.
if (downloaded_pages->empty()) {
  m->unlock();  // (Quiz) 여기서 unlock 을 안한다면 어떻게 될까요?

  // 10 밀리초 뒤에 다시 확인한다.
  std::this_thread::sleep_for(std::chrono::milliseconds(10));
  continue;
}

그러나 대기시간에 downloaded_pages->empty()를 지속적으로 수행하면 cpu낭비이므로
10ms 마다 downloaded_pages->empty()를 해서 cpu낭비를 막는다.
std::this_thread::sleep_for(std::chrono::milliseconds(10));

그런데 10ms마다 확인하는 것도 비효율적이다.
일이 왔을 때만 스레드를 깨우는 방법은?
Condition_variable
일정 조건을 만족할 때까지 sleep명령을 내릴 수 있다.
std::condition_variable cv;
std::unique_lock<std::mutex> lk(*m);

cv->wait(lk, [&] { return !downloaded_pages->empty() || *num_processed == 25; });
//람다함수 [&] 같은 영역의 모든 변수 참조로 추가.

wait 함수에 unique_lock 객체와 조건 함수를 넣어준다.
unique_lock은 lock_guard와 거의 동일하나 lock_guard와 달리 unlock후 다시 lock을 걸어줄 수 있다는 특징이 있다.

cv->notify_one();
//자고있는 쓰레드 중 하나를 깨워 조건을 다시 검사하게 해준다.

cv->notify_all();
//모든 쓰레드를 깨워 조건을 검사하게 한다.
//모든 task를 마친 후에 자고있는 쓰레드를 깨워 종료하게만드는데 사용할 수 있다.

wait_for은 조건 or 일정시간마다 깨움
wait_until 조건 or 특정시간이 되면 깨움.



