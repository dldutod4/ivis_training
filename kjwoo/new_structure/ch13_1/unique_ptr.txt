c++11에서 자원을 관리하는 방법
#include <iostream>

class A {
  int *data;

 public:
  A() {
    data = new int[100];
    std::cout << "자원을 획득함!" << std::endl;
  }

  ~A() {
    std::cout << "소멸자 호출!" << std::endl;
    delete[] data;
  }
};

void do_something() { A *pa = new A(); }

int main() {
  do_something();

  // 할당된 객체가 소멸되지 않음!
  // 즉, 400 바이트 (4 * 100) 만큼의 메모리 누수 발생
}

설령 delete pa를 했더라도 예외가발생해 실행되지않으면 pa는 소멸하지않는다. (객체가 아닌 포인터이므로)

Resource Acquisition Is Initialization - RAII
자원관리 방법 패턴. 자원의 획득은 초기화이다. 자원관리를 스택에할당된 객체를통해 수행하는것.

포인터를 객체로 만들면 포인터가 소멸할때 자신이 가진 데이터도 delete하게 만들 수 있다.
이런 포인터를 스마트 포인터라고 한다.

스마트포인터는 두가지 형태의 새로운 스마트포인터를 제공한다.
unique_ptr과 shared_ptr

unique_ptr 객체의 유일한 소유권

메모리관리에 문제가 생기는 경우 2가지
1.메모리사용후 해제하지 않은 경우 (memory leak)

2.이미 해제된 메모리를 다시 참조하는 경우


Data* data = new Data();
Date* data2 = data;

// data 의 입장 : 사용 다 했으니 소멸시켜야지.
delete data;

// ...

// data2 의 입장 : 나도 사용 다 했으니 소멸시켜야지
delete data2;

위와같이 이미 소멸된 객체를 소멸시키려할 경우를 double free 버그라 부름.

#include <iostream>
#include <memory>

class A {
  int *data;

 public:
  A() {
    std::cout << "자원을 획득함!" << std::endl;
    data = new int[100];
  }

  void some() { std::cout << "일반 포인터와 동일하게 사용가능!" << std::endl; }

  ~A() {
    std::cout << "자원을 해제함!" << std::endl;
    delete[] data;
  }
};

void do_something() {
  std::unique_ptr<A> pa(new A());
  pa->some();
}

int main() { do_something(); }

unique_ptr은 특정객체에 유일한 소유권을 부여하는 포인터 객체임.
포인터처럼 사용할 수있고 객체이기 때문에 소멸시에 가리키는 객체를 소멸시킬 수 있음. RAII패턴

unique_ptr을 복사하려한다면?

void do_something() {
  std::unique_ptr<A> pa(new A());

  // pb 도 객체를 가리키게 할 수 있을까?
  std::unique_ptr<A> pb = pa;
}

int main() { do_something(); }

삭제된 함수 사용오류가 발생한다.

삭제된 함수사용이란?
사용을 원치않는 함수를 삭제하는 기능이 있다. (c++11에 추가 )
#include <iostream>

class A {
 public:
  A(int a){};
  A(const A& a) = delete; //함수 삭제
};

int main() {
  A a(3);  // 가능
  A b(a);  // 불가능 (복사 생성자는 삭제됨) 복사생성자를 명시적으로 삭제해 사용시 컴파일 오류가발생.
}

unique_ptr의 복사생성자도 명시적으로 삭제되어있기때문에 복사하려고하면 삭제된함수오류가 발생한다.

unique_ptr 소유권 이전하기
복사는 안되지만 이전은 가능하다.

std::unique_ptr<A> pb = std::move(pa);
std::move가 필요한 이유는?

move를 안쓰면 unique_ptr<A>(const A&) 복사생성자가 호출되지만
move로 우측값으로 바꾸면 unique_ptr<A>(A&& )이동생성자가 호출되어 소유권이 이전된다.

소유권이 이전된 unique_ptr을 댕글링 포인터라고 하며 재참조시 런타임 오류.
소유권이 이전되면 댕글링 포인터를 절대 다시 참조않겠다는 확인하에 이동해야한다.

unique_ptr을 함수 인자로 전달하기

unique_ptr은 복사가 안되므로 인자로 복사해 전달이 안된다.
그렇다면 레퍼런스로 보내면 되나
unique_ptr은 유일한 소유권을 의미하는데 레퍼런스로 객체를 다루게되면 원칙에 위배된다.
올바르게 전달하려면 원래의 포인터 주소값을 전달해야한다.
이러면 소유권이라는 의미는 버리고 함수 내부에서 객체에 접근할 수 있는 권한을 준다는 의미가 된다.
void do_something(A* ptr){....};
do_something(pa.get());

    unique_ptr 은 어떤 객체의 유일한 소유권을 나타내는 포인터 이며, unique_ptr 가 소멸될 때, 가리키던 객체 역시 소멸된다.

    만약에 다른 함수에서 unique_ptr 가 소유한 객체에 일시적으로 접근하고 싶다면, get 을 통해 해당 객체의 포인터를 전달하면 된다.

    만약에 소유권을 이동하고자 한다면, unique_ptr 를 move 하면 된다.

unique_ptr을 쉽게 생성하기
make_unique 함수는 
아예 템플릿 인자로 전달된 클래스의 생성자에 인자들에 직접 완벽한 전달 을 수행
auto ptr = std::make_unique<Foo>(3, 5);

unique_ptr을 원소로 가지는 STL컨테이너
복사생성자가 없으므로
vec.push_back(pa) 같은건 삭제된함수 오류가 발생한다.
vec.push_back(std::move(pa))로 써야한다.

emplace_back함수를 쓰면 unique_ptr을 직접 생성하면서 전달을 할 수 있음
vec.emplace_back(new A(1));

emplace_back 함수는 전달된 인자를 완벽한 전달(perfect forwarding) 을 통해, 
직접 unique_ptr<A> 의 생성자에 전달 해서,   
vector 맨 뒤에 unique_ptr<A> 객체를 생성

emplace_back 을 사용 시에 어떠한 생성자가 호출되는지 주의
std::vector<int> v;
v.emplace_back(100000); //100000이라는 int값을 추가

std::vector<std::vector<int>> v;
v.emplace_back(100000); //원소가 100000개인 벡터를 추가

