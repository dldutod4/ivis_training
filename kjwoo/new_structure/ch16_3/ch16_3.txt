    decltype 키워드 설명

    C++ 의 값 카테고리 - lvalue, prvalue, xvalue

    std::declval 함수 설명

     decltype

decltype 키워드는 C++ 11 에 추가된 키워드로, decltype 라는 이름의 함수 처럼 사용

decltype(/* 타입을 알고자 하는 식*/)
decltype 는 함수와는 달리, 타입을 알고자 하는 식의 타입으로 치환

#include <iostream>

struct A {
  double d;
};

int main() {
  int a = 3;
  decltype(a) b = 2;  // int

  int& r_a = a;
  decltype(r_a) r_b = b;  // int&

  int&& x = 3;
  decltype(x) y = 2;  // int&&

  A* aa;
  decltype(aa->d) dd = 0.1;  // double
}

괄호로 둘러쌓이지 않은 식별자 표현식(id-expression) 이라면 해당 식의 타입을 얻을 수 있다.
식별자 표현식이란 어떠한 연산을 하지 않고 단순히 객체 하나만을 가리키는 식

만약 식별자 표현식이 아니라면
    만일 식의 값 종류가 xvalue 라면 decltype 는 T&& 가 됩니다.

    만일 식의 값 종류가 lvalue 라면 decltype 는 T& 가 됩니다.

    만일 식의 값 종류가 prvalue 라면 decltype 는 T 가 됩니다.

값 카테고리(value category) 
총 5가지의 값 카테고리를 갖는다.

                 이동가능            이동불가
정체를 알음     xvalue              lvalue
정체를 모름     prvalue             쓸모없음.

정체를 알수있는 식들을 glvalue라고 하고 이동시킬 수 잇는 모든 식들을 rvalue라고 함.


이름을 가진 대부분의 객체들은 모두 lvalue 

변수, 함수의 이름, 어떤 타입의 데이터 멤버 (예컨대 std::endl, std::cin) 등등

좌측값 레퍼런스를 리턴하는 함수의 호출식. std::cout << 1 이나 ++it 같은 것들

a = b, a += b, a *= b 같이 복합 대입 연산자 식들

++a, --a 같은 전위 증감 연산자 식들

a.m, p->m 과 같이 멤버를 참조할 때. 
이 때 m 은 enum 값이거나 static 이 아닌 멤버 함수인 경우 제외. (아래 설명 참조)

a[n] 과 같은 배열 참조 식들

문자열 리터럴 "hi"

lvalue 들은 주소값 연산자(&) 를 통해 해당 식의 주소값을 알아 낼 수 있습니다


prvalue 순수 우측값
문자열 리터럴을 제외 한 모든 리터럴들. 42, true, nullptr 같은 애들

레퍼런스가 아닌 것을 리턴하는 함수의 호출식. 예를 들어서 str.substr(1, 2), str1 + str2

후위 증감 연산자 식. a++, a--

산술 연산자, 논리 연산자 식들. a + b, a && b, a < b 같은 것들을 말합니다. 물론, 이들은 연산자 오버로딩 된 경우들 말고 디폴트로 제공되는 것들을 말합니다.

주소값 연산자 식 &a

a.m, p->m 과 같이 멤버를 참조할 때. 이 때 m 은 enum 값이거나 static 이 아닌 멤버 함수여야함.

this

enum 값

람다식 []() { return 0;}; 과 같은 애들.

prvalue 들은 식의 좌측에 올 수 없습니다. 
하지만 prvalue 는 우측값 레퍼런스와 
상수 좌측값 레퍼런스를 초기화 하는데 사용

xvalue
우측값 레퍼런스를 리턴하는 함수의 호출식 을 들 수 있습니다. 대표적으로 std::move(x)
 좌측값 처럼 정체가 있지만 이동도 시킬 수 있는 것들

     만일 식의 값 종류가 xvalue 라면 decltype 는 T&& 가 됩니다.

    만일 식의 값 종류가 lvalue 라면 decltype 는 T& 가 됩니다.

    만일 식의 값 종류가 prvalue 라면 decltype 는 T 가 됩니다.

    int a, b;
decltype(a + b) c;  // c 의 타입은?
a+b는 prvalue이므로 int

int a;
decltype((a)) b;  // b 의 타입은?
식별자 표현식이 아니고 lvalue이므로 int& //괄호로인해 차이가 발생한다.

