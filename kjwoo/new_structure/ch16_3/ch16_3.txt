    decltype 키워드 설명

    C++ 의 값 카테고리 - lvalue, prvalue, xvalue

    std::declval 함수 설명

     decltype

decltype 키워드는 C++ 11 에 추가된 키워드로, decltype 라는 이름의 함수 처럼 사용

decltype(/* 타입을 알고자 하는 식*/)
decltype 는 함수와는 달리, 타입을 알고자 하는 식의 타입으로 치환

#include <iostream>

struct A {
  double d;
};

int main() {
  int a = 3;
  decltype(a) b = 2;  // int

  int& r_a = a;
  decltype(r_a) r_b = b;  // int&

  int&& x = 3;
  decltype(x) y = 2;  // int&&

  A* aa;
  decltype(aa->d) dd = 0.1;  // double
}

괄호로 둘러쌓이지 않은 식별자 표현식(id-expression) 이라면 해당 식의 타입을 얻을 수 있다.
식별자 표현식이란 어떠한 연산을 하지 않고 단순히 객체 하나만을 가리키는 식

만약 식별자 표현식이 아니라면
    만일 식의 값 종류가 xvalue 라면 decltype 는 T&& 가 됩니다.

    만일 식의 값 종류가 lvalue 라면 decltype 는 T& 가 됩니다.

    만일 식의 값 종류가 prvalue 라면 decltype 는 T 가 됩니다.

값 카테고리(value category) 
총 5가지의 값 카테고리를 갖는다.

                 이동가능            이동불가
정체를 알음     xvalue              lvalue
정체를 모름     prvalue             쓸모없음.

정체를 알수있는 식들을 glvalue라고 하고 이동시킬 수 잇는 모든 식들을 rvalue라고 함.


이름을 가진 대부분의 객체들은 모두 lvalue 

변수, 함수의 이름, 어떤 타입의 데이터 멤버 (예컨대 std::endl, std::cin) 등등

좌측값 레퍼런스를 리턴하는 함수의 호출식. std::cout << 1 이나 ++it 같은 것들

a = b, a += b, a *= b 같이 복합 대입 연산자 식들

++a, --a 같은 전위 증감 연산자 식들

a.m, p->m 과 같이 멤버를 참조할 때. 
이 때 m 은 enum 값이거나 static 이 아닌 멤버 함수인 경우 제외. (아래 설명 참조)

a[n] 과 같은 배열 참조 식들

문자열 리터럴 "hi"

lvalue 들은 주소값 연산자(&) 를 통해 해당 식의 주소값을 알아 낼 수 있습니다


prvalue 순수 우측값
문자열 리터럴을 제외 한 모든 리터럴들. 42, true, nullptr 같은 애들

레퍼런스가 아닌 것을 리턴하는 함수의 호출식. 예를 들어서 str.substr(1, 2), str1 + str2

후위 증감 연산자 식. a++, a--

산술 연산자, 논리 연산자 식들. a + b, a && b, a < b 같은 것들을 말합니다. 물론, 이들은 연산자 오버로딩 된 경우들 말고 디폴트로 제공되는 것들을 말합니다.

주소값 연산자 식 &a

a.m, p->m 과 같이 멤버를 참조할 때. 이 때 m 은 enum 값이거나 static 이 아닌 멤버 함수여야함.

this

enum 값

람다식 []() { return 0;}; 과 같은 애들.

prvalue 들은 식의 좌측에 올 수 없습니다. 
하지만 prvalue 는 우측값 레퍼런스와 
상수 좌측값 레퍼런스를 초기화 하는데 사용

xvalue
우측값 레퍼런스를 리턴하는 함수의 호출식 을 들 수 있습니다. 대표적으로 std::move(x)
 좌측값 처럼 정체가 있지만 이동도 시킬 수 있는 것들

     만일 식의 값 종류가 xvalue 라면 decltype 는 T&& 가 됩니다.

    만일 식의 값 종류가 lvalue 라면 decltype 는 T& 가 됩니다.

    만일 식의 값 종류가 prvalue 라면 decltype 는 T 가 됩니다.

    int a, b;
decltype(a + b) c;  // c 의 타입은?
a+b는 prvalue이므로 int

int a;
decltype((a)) b;  // b 의 타입은?
식별자 표현식이 아니고 lvalue이므로 int& //괄호로인해 차이가 발생한다.

decltype 의 쓰임새
auto가 더 편한데 왜쓰나
auto는 엄밀히 정확한 타입을 표현하지 않는다.
const int i = 4;
auto j = i;         
decltype(i) k = i;  

auto의 경우 const를 없애버리지만
decltype은 const를 보존한다.

즉 decltype 를 이용하면 타입 그대로 정확하게 전달

std::declval 함수 <utility>에 정의된 함수.

struct A{
  int f() { return 0;}
};

decltype(A().f()) ret_val; //int ret_val;

decltype 안에 들어가는 식은, 그냥 식의 형태로만 존재할 뿐 컴파일 시에, decltype() 전체 식이 타입으로 변환된다.
그래도 문법이 틀리면 컴파일 오류가 발생해서 생기는 문제가 있는데


template <typename T>
decltype(T().f()) call_f_and_return(T& t) {
  return t.f();
}
struct A {
  int f() { return 0; }
};
struct B {
  B(int x) {}
  int f() { return 0; }
};

int main() {
  A a;
  B b(1);

  call_f_and_return(a);  // ok
  call_f_and_return(b);  // BAD
}

이런 식으로 decltype안에 직접 생성자를 넣게되면
인자 T의 실제 생성자가 필요하지않은 경우에도 T가 생성자가 구현이 되어있어야하는 문제가 생김.


std::declval 에 타입 T 를 전달하면, 
T 의 생성자를 직접 호출하지 않더라도 T 가 생성된 객체를 나타내 해결된다.
#include <utility>

template <typename T>
decltype(std::declval<T>().f()) call_f_and_return(T& t) {
  return t.f();
}
struct A {
  int f() { return 0; }
};
struct B {
  B(int x) {}
  int f() { return 0; }
};

int main() {
  A a;
  B b(1);

  call_f_and_return(a);  // ok
  call_f_and_return(b);  // ok
}

declval 함수를 타입 연산에서만 사용해야지, 실제로 런타임에 사용하면 오류가 발생합니다.
#include <utility>

struct B {
  B(int x) {}
  int f() { return 0; }
};

int main() { B b = std::declval<B>(); }

사실 함수의 리턴타입을 알아서 유추하는 기능이 생겼기 때문에
 decltype이나 declval로 타입을 지정할 필요없이 auto로 하면 되긴 했지만
템플릿 메타프로그래밍에 사용할 수 있다.