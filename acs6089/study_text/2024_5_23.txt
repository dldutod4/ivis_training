5월 23일 목요일 

13-2까지 진행을 목표

10-4. 씹어먹는 C++ - <10 - 4. C++ 문자열의 모든 것 (string 과 string_view)>

basic_string 클래스는 아래와 같은 구조를 갖는다.
template <class CharT, class Traits = std::char_traits<CharT>,
          class Allocator = std::allocator<CharT> >
class basic_string;
CharT 타입의 객체들을 메모리에 연속적으로 저장하고 문자열 연산들을 지원한다.
CharT 자리에 char가 들어가면 우리가 흔히 쓰는 std::string이 되고 CharT 자리에 char말고도 다양한 UTF 문자열을 보관할 수 있다.
Traits는 주어진 문자열 연산들을 정의해 놓은 클래스이다. 문자와 문자열들 간에 간단한 연산을 제공해주는 클래스 이므로 데이터를 저장할 필요없다.(Stateless)
좀더 다양한 로직을 자유롭게 적용할 수 있도록 문자열들을 어떻게 보관하는지는 CharT가 담당하고 문자열들을 어떻게 연산할지는 Trairs가 담당하게된다.

짧은 문자열 최적화(Short String Optimization)
메모리 할당 및 재할당은 시간이 많이 소요되는 작업이다. 문자열을 처리할 때 대부분 한 두줄의 짧은 문자열을 처리하고 가끔만 매우 긴 문자열을 처리한다. 이런 자주 사용되는 짧은 문자열들을 매번 메모리 할당 및 재할당 작업을 하게되면 시간적으로 손해이기에 basic_string 클래스에서는 짧은 길이의 문자열을 위해 문자열을 할당하는 대신 객체 자체에 저장하고 이를 짧은 문자열 최적화라고 한다.

문자열 리터럴 정의하기
auto str = "hello"를 하게되면 str은 std::string으로 정의되는게 아니라 const char*로 정의된다.
따라서 std::string으로 사용하고 싶으면 std::string str = "hello"으로 사용해야하지만 C++ 14이후 부턴 리터럴 연산자를 이용해 auto str = "hello"s와 같이 사용해도 std::string으로 정의된다. 또한 Raw string literal은 R"/* delimiter */( )/* delimiter */"에서 () 안에 들어 있는 모든 문자(\n \t " ')를 모든 문자 그대로 char 배열안에 들어가게 해주는 literal이다.

유니코드 : 전세계의 모든 문자들을 컴퓨터로 표현할 수 있도록 설게된 표준
현재 컴퓨터에 등록된 모든 문자들을 저장할려면 4바이트가 필요. 하지만 영어와 같이 알파벳만 쓸경우 항상 4바이트를 사용시 비효율적이기에 문자를 1~4바이트로 표현하는 UTF-8, 2또는 4바이트로 표현하는 UTF-16, 무조건 4바이트로 표현하는 UTF-32 이렇게 4가지 경우로 인코딩한다. 한글의 경우 UTF-8에서 0xAC00에서 0xD7AF까지 배정되어 있어 한 글자에 3바이트를 필요로 한다. 반면 UTF-16에서는 알파벳, 한글, 한자 전부 2바이트로 인코딩되기에 한글 스트링을 많이 다룬다면 UTF-16 인코딩 방식도 유용하다.

string_view
어떠한 문자열을 읽을 때 const string&로 읽게 되면 (const char*)의 문자열 리터럴을 전달하면 const string 객체를 별도로 생성해서 저장하는 메모리 낭비가 발생한다. 반대로 읽는 함수의 인자를 const char*로 바꾸면 함수는 문자열의 길이나 string이 가지고 있는 정보를 볼수 없게 되고 원래 문자열 string 에서 const char*를 추출해야한다. 따라서 복사하거나 건들지 않고 말그대로 문자열을 읽기만 하는 클라스 string_view를 C++ 17에서부터 지원한다.딴 읽기만 지원하므로 꼭 대상 문자열이 있는지 확인해야한다.



11. C++ 에서 예외 처리

문법상 틀리지 않지만 실제로는 오류가 발생할 수 있고 이렇게 정상적인 상황에서 벗어난 모든 예외적인 상황들을 예외(exception)이라 한다.
C에서는 어떤 작업을 실행한 뒤에 그 결과값을 확인하는 방식으로 처리했다. 해당 방식은 함수가 깊어지면 정확히 어디서 예외가 발생했는지 찾아내는데 시간이 많이 소모된다. 

예외 발생 - throw
C++에서는 throw라는 예외에서 발생하였다는 사실을 명시적으로 나타낸다. 만약 예외를 던지고 싶으면, throw로 예외로 전달하고 싶은 객체를 써주면된다.
예외로 던질 때 아무 객체나 던져도 상관은 없지만 C++에서 제공하는 out_of_range, overflow_error, length_error, runtime_error 등등 여러가지 정의 되어있는 표준 라이브러리를 활용하는 경우도 있다. 이렇게 예외가 발생한 부분에서 throw 이용하면 throw한 위치에서 함수가 즉시 종료되고 해당 부분까지 도달하는데 stack에 생성되어 있던 객체들을 빠짐없이 소멸시켜준다. 

예외 처리 - try, catch
try 안에서는 무언가 예외가 발생할만한 코드를 실행한다.만약 예외가 발생하지 않았다면 try, catch부분이 없는 것과 동일하게 실행한다. 반면 예외가 발생하면 그 즉시 stack에 생성된 모든 객체들의 소멸자들이 호출되고 가장 가까운 catch로 점프한다. 또한 catch는 여러 종류의 exception을 받을 수 있고 이를 처리할려면 각 exception에 대한 catch를 모두 사용해주면 적절한 exception에 맞는 catch로 switch문 처럼 시행해준다. 모든 예외를 받고 싶으면 catch(...)와 같이 사용하면된다. 특히 템플릿으로 정의되는 클래스 내부에서 exception을 받고 싶으면 해당 템플릿이 어떻게 인스턴스화되냐에 따라 발생하는 exception의 종류가 달라질 수 있기때문에 모든 예외를 받는 catch를 사용해야한다.

스택 풀기(stack unwinding)
정상적인 상황에서는 객체의 소멸자들은 함수가 종료될 때 호출 되지만 exception 전파시에는 가장 가까운 catch로 점프하며 각 함수들에 있던 객체들만 해체하고 내부의 명령들을 수행하지 않는다. **단 생성자에서 예외가 발생하면 소멸자가 호출되지 않는다.**



12-1. 우측값 레퍼런스와 이동 생성자

복사 생략 Copy Elision
class A {
  int data_;

 public:
  A(int data) : data_(data) { std::cout << "일반 생성자 호출!" << std::endl; }

  A(const A& a) : data_(a.data_) {
    std::cout << "복사 생성자 호출!" << std::endl;
  }
};
int main(){
  A(c(A(2)));
}
위와 같은 상황에서 컴파일러는 c라는 임시 객체를 A(2)를 생성하고 굳이 다시 복사하기보단 어차피 바로 A(2) 자체를 바로 c로 만들어 버려 복사를 생략한다.
반드시 생략하는 것은 아니고 생략을 할 수 도 있다는 것을 보여준다.

좌측값 lvalue, 우측값 rvalue
주소값을 취할 수 있는 값을 좌측값이라 하고 주소값을 취할 수 없는 값을 우측값이라 부릅니다. 우측값은 항상 식의 오른쪽에 존재해야한다.

class MyString {
  char *string_content;  // 문자열 데이터를 가리키는 포인터
  int string_length;     // 문자열 길이
  int memory_capacity;  // 현재 할당된 용량
}
만약 위와 같은 클래스의 문자열을 저장하는 객체 str1과 str2를 str1 + str2와 같이 사용하여 리턴할 경우 임시 객체가 생성된다. 이렇게 사용한 리턴값을 새로운 우측값 str3에 집어 넣을려하면 임시 객체의 string_content를 전부 복사하여 str3의 string_content에 메모리를 할당하고 집어 넣어줘야한다. 여기서 임시 객체의 string_content 포인터를 그대로 str3의 string_content 포인터에 넣으면 전부 복사하지 않아도 값을 대로 가져올 수 있다. 이렇게 복사를 끝낸 다면 임시 객체는 소멸하게 되므로 임시 객체의 string_content는 삭제되게 되고 이때문에 str3의 string_content도 참조할 수 없게 된다. 그래서 임시 객체의 string_conent 포인터를 nullptr로 바꾸고 소멸자에서 string_conent가 nullptr를 가르키고 있으면 delete시키지 않게하여 임시 객체가 소멸 되어도 strng_content의 메모리는 살리 수 있게 한다. 

위와 같이 객체가 다른 객체로부터 자원을 이동할 수 있도록 하는 것을 이동 생성자라고 한다. 이러한 이동 생성자를 사용할 때 주의해야할 점은 이동 생성자를 반드시 noexcept로 명시해야한다. vector에서 이동 생성자를 사용할 때 새로운 원소를 추가함으로서 할당한 메모리 부족으로 더 큰 메모리를 할당 받고 해당 위치로 원소들을 옮기는 과정에서 exception이 발생한다면 원래 vector는 처음부터 다시 수행하면되지만 이동 생성자를 사용한 vector는 이미 새로운 메모리에 원래 원소들을 이동 생성자를 사용해 새로운 메모리로 옮겨버렸기 때문에 새로운 메모리를 해제하면 원소들을 찾지 못할 수도 있다.



12-2. Move 문법 (std::move semantics) 과 완벽한 전달 (perfect forwarding)

우리가 생각하는 swap 함수는 temp라는 임시 객체를 생성한뒤 a를 temp에 복사하고 b를 a에 복사한다음 마지막으로 temp를 b에 복사하는 순서로 진행한다.
위의 경우 무려 3번의 복사가 일어난다. 해당 객체들이 작을 경우 큰 문제가 되지 않겠지만 매우 긴 문자열들일 경우 메모리를 많이 쓰며 시간도 많이 걸리게 된다.
a를 잠시 다른데 옮겨 놓고 이동 생성자를 이용해서 a,b를 옮겨 주면 좋지만 문제는 a, b 모두 실체가 있는 좌측값이라 이동 생성자는 오버로딩 되지않는다.(이동 생성자는 우측값 참조를 매개변수로 받도록 설계되어 있기때문이다.) 이때 좌측값을 우측값으로 취급할 수 있게해주는 move 함수를 사용하면 된다. *move 함수는 무엇인가를 이동시킬것 같지만 실제로는 인자로 받은 객체를 우측값으로 리턴만 해주는 함수이다.* 따라서 실제로 데이터가 이동하는 과정은 move 함수를 사용할 때가 아니라 이동 생성자나 이동 대입 연산자를 호출할 때 일어난다.

완벽한 전달(perfect forwarding)
함수 템플릿에서 인수를 다른 함수로 전달할 때, 그 인수의 타입과 값 속성을 유지해야할 때 완벽한 전달이 필요하다.

template <typename T>
void wrapper(T&& u)
위와 같이 어떤 템플릿 인자 T에 대해서 우측값 레퍼런스를 받는 형태를 보편적 레퍼런스라고 한다.
여기서 들어오는 u가 우측값인지 좌측값인지 일정하지 않을 경우 forward 함수를 사용하여 u가 우측값 일때만 move를 적용한것 처럼 작동하게 해준다.



13-1. 객체의 유일한 소유권 - unique_ptr

자원(resource) 관리의 중요성
C++ 이후에 나온 많은 언어들은 Garbage Collector라 부르는 쓰지 않는 자원을 회수하는 자원 청소기가 기본적으로 내장되어 있다. 하지만 C++은 한 번 획득한 자원은 직접 해제해주지 않는 이상 프로그램이 종료되기 전 까지 영원히 남아있다.(단 프로그램이 종료되면 운영체제가 알아서 자원들을 회수한다.) 항상 배정된 자원을 회수하는 것이 좋지만 프로그램이 매우 커지거나 중간에 exception 같은 것이 발생하여 해제를 못하고 바로 throw부분으로 넘어갈 경우 자원을 회수 하지 못 할 수있다.
따라서 C++에서는 자원을 효율적을 관리할 필요가 있고 이에 대한 방법으로 자원의 획득은 초기화(RAII, Resource Acquisition Is Initialization)라는 디자인 패턴을 제시되었다. 어떠한 포인터가 있을 경우 사용이 끝나도 그 포인터가 가르키는 데이터는 사라지지 않지만 이 포인터를 객체로 만들어서 자신이 가리키고 있는 데이터도 같이 delete하게 하면 자원 관리를 스택의 객체를 통해 수행하게 된고 이렇게 작동하는 포인터 객체를 스마트 포인터(smart pointer)라고 부른다. C++에는 unique_ptr과 shared_ptr 두가지의 스마트 포인터 사용을 권장한다.

unique_ptr
C++에서 메모리를 잘 못 관리하면 크게 2가지의 문제점이 발생한다. 하나는 지속되는 메모리 누수로 결국 메모리가 부족해져서 시스템 전체나 프로그램이 다운될 수 있고 다른 하나는 이미 해제된 메모리를 다시 참조하는 경우이다. 특히 이미 소멸된 객체에 접근하는 것 뿐만 아니라 다시 소멸 시키는 2중 소멸시 오류를 발생할 수 있다. 이를 해결하기 위해 어떤 객체가 어떤 포인터에 유일한 소유권을 부여하여 다른 객체가 함부로 소멸 시킬 수 없게 한다면 두번 소멸 시킬 수 없을 것이고 이렇게 유일한 소유권을 부여하는 포인터 객체를 unique_ptr이라 한다. 만약 unique_ptr을 복사할려 하면은 삭제된 함수를 사용하려고 했다는 오류를 띄운다. 해당 오류를 띄우는 이유는 unique_ptr는 어떠한 객체가 유일하게 소유해야하기 때문에 unique_ptr의 복사 생성자가 명시적으로 삭제되었기 때문이다. unique_ptr는 복사되지는 않지만 소유권의 이전은 가능하고 move 함수를 통해서 이전을 한다. 만약 소유권을 이전시키면 이전된 unique_ptr를 댕글링 포인터라고 하며 이를 재 참조할 시에 런타임 오류가 발생한다. unique_ptr를 함수의 인자로써 전달하고 싶으면 unique_ptr 자체를 전달하는 것이 아니라 unique_ptr가 가르키는 원래 포인터 주소를 get을 통해 해당 객체의 포인터를 전달해 주면된다. 또한 unique_ptr을 간단히 만들 수 있는 std::make_unique를 제공한다.

unique_ptr는 다른 타입들과 큰 차이는 없지만 복사 생성자가 없다는 불편한 점이 있다. vector는 원소를 빼거나 집어 넣을 때 전달된 인자를 복사해서 집어 넣기 때문에 unique_ptr를 사용할려면 emplace_back 함수를 이용하여 vector 안에 직접 unique_ptr를 직접 생성하면서 집어 넣는다.




13-2. 자원을 공유할 때 - shared_ptr 와 weak_ptr

대부분의 경우 하나의 자원은 한 개의 스마트 포인터에 의해 소유되는 것이 바람직하지만 때에 따라서 여러 개의 스마트 포인터가 하나의 객체를 같이 소유해야하는 경우가 발생한다. 이 하나의 자원을 모두 사용한 이후에 이 자원을 사용하는 모든 객체들이 소멸되어야 하는데 어떤 객체가 먼저 소멸되는지 알 수 없기 떄문에 이 자원 역시 어느 타이밍에 해제 시켜야 할 지 알 수 없게 됩니다. 그렇기에 특정 자원을 몇 개의 객체에서 가르키는지 추적한 다음에 그 수가 0이 되면 비로소 해제하는 방식의 포인터가 shared_ptr이다.


