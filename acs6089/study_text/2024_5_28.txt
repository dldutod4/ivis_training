5월 28일 화요일

17-5를 목표로 학습하겠습니다.

17-1. type_traits 라이브러리, SFINAE, enable_if

함수는 아니지만 마치 함수 처럼 동작하느 템플릿 클래스들을 템플릿 메타 함수라 한다. 일반 함수는 값에 대해서 연산을 수행하지만 메타 함수는 타입에 대해 연산을 수행한다. 템플릿 메타 함수는 이름에 함수가 들어가지만 실제로는 함수가 아니다. 함수들은 ()를 통해서 인자들을 받고 호출하지만 메타 함수는 <>를 통해 함수 인자가 아닌 템플릿 인자를 전달 받는다. 특히 타입들에 대한 여러가지 연산을 수행할 수 있는 type_traits를 C++에서 표준 라이브러리로 지원하고 있다.

is_void
template <typename T>
struct is_void {static constexpr bool value = false;};
template <>
struct is_void<void> {static constexpr bool value = true;};
is_void 함수는 위와 같이 특수 타입 void일 때만 true를 반환하고 그외의 경우 false를 반환 함으로서 대상이 void 타입인지 아닌지 판별한다.

데이터 맴버를 가리키는 포인터
int T::*는 T의 int 맴버를 가르키는 포인터라는 의미이다.
class A {
 public:
  int n;
  A(int n) : n(n) {}
};
int main() {int A::*p_n = &A::n;}
위의 경우 p_n은 A의 int 맴버를 가리킬 수 있는 포인터를 의미하지만 p_n이 실제 존재하는 어떤 int 맴버를 가르키는 것이 아니다. p_n을 역참조하게 되면 A의 n을 참조하는 식으로 사용할 수 있습니다. 해당 문법은 오직 클래스에서만 사용할 수 있다. 따라서 int T::*는 T가 클래스가 아니라면 사용할 수 없는 문장이다. 대신 T 내부에 int인자가 없어도 문장에 오류 없이 사용가능하다.


template <typename T>
void test(typename T::x a) {std::cout << "T::x \n";}
template <typename T>
void test(typename T::y b) {std::cout << "T::y \n";}
struct A {using x = int;};
struct B {using y = int;};
int main() {test<A>(33);}
위의 코드에서 test 템플릿 함수는 인자로 x,y를 받는다. 여기서 A는 y라는 맴버 변수가 없기에  void test(typename T::y b) 문장은 문법적으로 올바르지 않다. 여기서 치완 오류는 컴파일 오류가 아니기에(SFINAE:Substitution Failure Is Not An Error) 컴파일은 되나 문법적으로 맞지 않는 문장은 단순히 함수의 오버로딩 후보군에서 제외된 상태로 컴파일이 진행된다. 단 컴파일러는 단순히 함수의 인자들과 리턴 타입만이 문법적으로 올바른지만을 확인하고 함수 내용 전체가 문법적으로 올바른지는 확인하지 않는다.

enable_if
enable_if는 SFINAE를 통해서 조건에 맞지 않는 함수들을 오버로딩 후보군에서 쉽게 뺄 수 있게 도와주는 간단한 템플릿 메타 함수 이다.
타입 의존성은 템플릿 매개변수에 따라 타입이 결정되는 경우를 말하는데 enable_if는 조건이 참일 떄 특정 타입을 정의 하고 조건이 거짓일 때는 해당 타입을 저의하지 않는 템플릿이어서 이를 통해 컴파일 타임에 특정 조건을 체크하여 조건에 따라 컴파일 여부를 결정한다.

template <typename T, typename = decltype(std::declval<T>().func())>
void test(const T& t) {std::cout << "t.func() : " << t.func() << std::endl;}
어떠한 맴버 함수가 있는 타입을 인자로 받는 함수를 만들때  위와 같은 방법으로 사용하면 func()있는 클래스만 받을 수 있다.

void_t
가변길이 템플릿을 이용해서 void_t에 템플릿 인자로 임의의 개수의 타입들을 전달할 수 있고 전달된 템플릿 인자들 중 문법적으로 올바르지 못한 템플릿 인자가 있다면 SFINAE에 의해서 오버로딩 목록에서 제외된다.




17-2. C++ 정규 표현식(<regex>) 라이브러리 소개

정규 표현식은 문자열에서 주어진 규칙에 맞는지 확인하거나, 원한느 패턴의 문자열을 검색하거나, 원하는 패턴의 문자열로 치환할 때 많이 사용된다.

전체 문자열 매칭하기
정규 표현식을 사용할려면 먼저 정규 표현식 객체를 정의해야한다. 특정 파일이 db-(시간)-log.txt 옆과 같은 모습을 하고 있다면 정규 객체를 표현할 때 std::regex re("db-\\d*-log\\.txt")와 같이 사용하여 \d*는 임의의 개수의 숫자를 의미한다.
std::regex_match(file_name, re) 앞서 생성된 정규 표현식 객체 re를 옆의 regex_match에서 사용하게 되면 re객체와 완전히 매칭 된다면 true를 리턴한다.

부분 매칭 뽑아내기
패턴의 일부분만 뽑아내고 싶다면 몇몇 조건들을 설정하고 정규 표현식을 사용해야한다. 예를 들어 전화번호를 정규 표현식으로 받을 때 (숫자)-(숫자)-(숫자) 꼴이고 맨 앞자리는 반드시 3자리이며 0,1로만 이루워져 있고 가운데 자리는 3자리 또는 4자리이며 마지막은 4자리라는 조건이 필요하다. 이를 정규 표현식으로 표현하면 [01]{3}-\d{3,4}-\d{4}로 표현할 수 있다. [01]은 0또는 1이라는 뜻이고 {}안에 있는 숫자는 해당 종류의 문자가 몇번 나타날 수있는지 나타내는 표현식이다. 만약 특정부분을 추출하고 싶다면 ()을 쳐줘서 추출하면된다.

원하는 패턴 검색하기
HTML 문서에서 <div class="sk...">...</div>와 같은 문자열들을 읽기 위해서 <div class="sk[\w -]*">\w*</div> 와 같은 정규 표현식이 필요하다. 문자열에서 원하는 패턴을 검색하는 일은 std::regex_search(html, match, re)와 같이 사용하면된다. regex_iterator는 주어진 문자열을 정규 표현식에서 쭉 뽑아낼 수 있어 사용하면 좀 더 편리하게 검색을 수행할 수 있다.

원하는 패턴 치환하기
위와 같이 원하는 패턴을 검색해서 해당 위치를 알아내고 그 위치에 원하는 패턴으로 교환하고 싶다면 regex_replace를 사용하면된다. 예를 들어 sk-circle\d를 찾아내어 \d-sk-circle로 만들고 싶다면 일단 sk-circle\d에서 숫자부분인 \d를 추출하기 위해 sk-circle(\d)를 사용하여 추출한다. 첫번째 캡처 그룹을 원하는 부분에 치환할 때 $(숫자) 부분에 치환을 시행하기에 $1-sk-circle이라고 표현한다.




17-3. 난수 생성(<random>)과 시간 관련 라이브러리(<chrono>) 소개

random
컴퓨터에서 난수 값을 사용하고 싶으면 rand() 함수를 사용한다. 하지만 컴퓨터는 실제로 진짜 난수를 생성하는 것이 아닌 첫 번째 수만 무작위로 정하고 그 다음 수는 난수처럼 보이지만 실제로는 무작위로 생성된 것이 아닌 수열들을 만들게 된다. 여기서 무작위로 정해진 첫 번째 수를 시드라고 하는데 보통은 프로그램을 실행했던 초를 시드값으로 지정한다. 하지만 동시에 프로그램을 실행한다면 똑같거나 비슷한 수열을 생성하기도 한다. 또한 rand()는 0부터 RAND_MAX까지의 숫자를 반환하기에 RAND_MAX의 약수로 나누는 것이 아닌이상 모든 숫자를 균등하게 생성하는 것도 아니다. 따라서 개선된 난수 생성 함수인 random 함수를 사용하면 조금 더 좋은 난수 값을 얻을  수 있다. 특히 사용 장치의 노이즈를 이용한 random_device를 사용하여 진정한 난수 시드를 얻을 수 있다.
난수 값을 사용할 때는 얻을 난수 값의 범위를 나타내는 분포 범위를 정해야한다. 또한 어떠한 분포를 사용할지도 정하면 좋다

chrono
chrono는 현재 시간을 알려주는 시계인 system_clock, 특정 시간을 나타내는 time_stamp, 시간의 간격을 나타내는 duration으로 구성되어 있다.
특히 std::high_resolution_clock을 사용하면 몇 번의 틱이 발생하는지 알려주는 time_stamp 객체를 리턴한다. clock 마다 1초에 생성하는 틱의 횟수가 모두 다르기 때문에 나중에 실제 시간으로 변환 시 어떤 clock을 사용했는지 정보가 필요하다.




17-4. C++ 파일 시스템(<filesystem>) 라이브러리 소개

filesystem 라이브러리는 파일 데이터의 입출력을 담당하는 fstream과는 다른 역활을 한다. fstream의 경우 파일 하나가 주워지면 해당 파일의 데이터를 읽어내는 역할을 하지만 파일에 관한 정보 데이터를 수정할 수는 없다. 따라서 어떠한파일을 찾고 싶다면 filesystem 라이브러리를 찾은 파일을 읽고 싶다면 fstream을 사용하면된다. 또한 filesystem은 원하는 경로에 폴더를 추가한다던지, 파일을 삭제한다던지, 파일의 생성 시간, 권한 같은 정보들을 보는데도 사용한다. 

경로
컴퓨터 상의 모든 파일에는 해당 파일의 위치를 나타내는 고유 주소가 있는데 이를 경로라고 한다.
절대 경로는 최상위 디렉토리에서 내가 목표하는 파일까지의 경로를 의미한다. 상대 경로의 경우 현재 프로그램이 실행되고 있는 위치에서 해당 파일을 찾아가는 경로를 의미한다. 원하는 경로에 있는 파일/디렉토리의 path를 정의하고 해당 path로 파일/디렉토리 정보를 수집한다. 해당 path에 실제로 파일이 존재하는지 아닌지 보려면 아래와 같이 exists함수를 사용해서 알아내야한다.

디렉토리 관련 작업들
해당 디렉토리 안에 있는 파일/폴더들 살펴보기, 해당 디렉토리 안에 폴더 생성하기, 해당 디렉토리 안에 파일/폴더 복사하기, 해당 디렉토리 안에 파일/폴더 삭제하기 등의 작업을 진행한다. 
디렉토리를 파일을 탐색하고 싶으면 directory_iterator를 사용하고 해당 디렉토리 내부의 또 다른 디렉토리가 있고 그 디렉토리 안도 탐색하고 싶다면 recursive_directory_iterator를 사용하여 탐색한다. 단 디렉토리의 구조가 바뀔 때 마다 무효화 된다.
디렉토리를 생성하고 싶으면 create_directory 함수를 사용하면된다. 단 생성한느 디렉토리의 부모 디렉토리는 반드시 존재해야한다."./a/c"에서 a안에 c라는 디렉토리를 생성하고 싶으면 c의 부모 디렉토리인 a가 존재해야지 생성이 가능하다.
copy를 사용하면 디렉토리 하위의 파일들 또는 모든 디렉토리와 파일들을 복사할 수 있다.
remove를 통하여 해당 디렉토리를 지울수 있으나 반드시 해당 디렉토리는 빈 디렉토리여야한다.
