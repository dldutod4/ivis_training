6월 4일 화요일


토막글 2 - 람다(lambda) 함수

람다 함수는 Functor에 들어갈 내용을 별도의 구조체를 정의하면서 까지 쭉 써내려갈 내용을 한번에 깔끔하게 정리해 놓은 것이다.
람다 함수는 [개시자](인자)->반환타입{함수의 몸통}으로 이루워져 있다.
[]는 개시자로 그 안에 어떤 외부 변수를 써 넣는다면 람다 함수가 이를 캡쳐해서 이 변수를 람다 내부에서 이용할 수 있게 된다.
()는 람다가 실행시 받을 인자들을 넣는다. ->는 반환타입을 쓰면된다.
중간중간에 받는 인자가 없으면 생략이 가능하다. 대신 개시자 []는 생략이 불가하다.

capture
람다 안에서 람다 밖의 변수들을 접근하고 싶을 때가 있을 때 해당 변수들을 ()인자로 받아 온다고 생각할 수 있다. for_each, fill, transform 등의 다양한 STL을 수행하기 위해서는 인자들을 맞춰 주어야하는데 이러한 것들은 ()인자로 받을 수가 없다. 이러한 문제를 해결하고자 람다 내부와 소통할 수 있는 또 다른 문, 캡쳐를 제공한다. [&](){}와 같이 사용하면 외부의 모든 변수들을 레퍼런스(call-by-reference)로 가져온다. [=](){}와 같이 사용하면 외부의 모든 변수들을 값(call-by-value)으로 가져온다. [=, &x, &y](){}와 같이 사용하면 외부의 모든 변수들의 값을 가져오고 x, y는 레퍼런스로 가져온다. 람다 함수로 생성되는 클로져 객체가 생성될 때 캡쳐가 이루워 지고 이때 전달된 값은 const 속성이 붙는다. 만약 내부에서 값을 바꾸고 싶다면  mutable 속성을 추가하면되고 이렇게 내부에서 변경된 값들은 원래 캡쳐 대상이었던 값을 변동시키지 않는다. 람다 함수는 this를 암묵적으로 캡쳐할 수 있다. 따라서 특정한 값을 this로 캡쳐했을 경우 const속성이 아니라 this.value로 암묵적으로 불러온 경우 값을 변경할 수 있다. 캡쳐 되는 개체들은 모두 람다가 정의된 위치에서 접근이 가능해야한다.

클로져 객체의 복사 생성자와 소멸자
모든 클로져 객체들은 암묵적로 정의된 복사 생성자와 소멸자를 가지고 있습니다. 기본적으로 클로져 객체가 복사 생성될 때 값으로 캡처된 값들도 같이 복사 생성이 일어난다. 반면에 레퍼런스로 캡쳐를 하게 되면 복사 생성자가 호출되지 않는다.

람다의 전달 및 저장
생성된 클로져 객체의 타입이 정확히 무엇인지 몰라도 auto를 이용해 성공적으로 저장할 수 있다. 또는 함수 포인터를 사용하여 저장 및 전달을 시행할 수 있는데, 이 경우에는 람다 함수가 캡쳐하는 것이 없어야만 가능하다. 위의 방법 외에도 function이라는 함수를 사용하여 어떤 클로져 객체나 함수 등을 모두 보관하고 전달할 수 있는 기능을 제공한다. 




토막글 3 - SFINAE 와 enable_if

템플릿과 오버로딩을 같이 사용한다면 템플릿이 너무 잘 적용되어서 함수의 오버로딩과 같이 사용했을 의도하지 않은 결과가 나올때가 있다.

SFINAE
컴파일러가 템플릿으로 선언된 오버로딩 후보들을 살펴볼 때, 템플릿 인자들의 타입들을 유추한 후에 이로 치환하는 과정에서 의도하지 않은 코드를 생산할 때가 있다.
템플릿 인자를 사용하는 함수의 즉각적인 맥락의 타입이나 구문(함수에서 템플릿 인자에의해 바로 치환되는 부분)만이 치환에 실패할 경우 컴파일러는 이 오류를 무시하고 그냥 오버로딩 후보에서 제외한다. 다시 말해 치환 실패는 오류가 아니다. Subsitution Failire Is Not An Error(SFINAE)라 한다. 

enable_if - 템플릿들을 위한 컴파일 타임 스위치
enable_if는 조건부 컴파일을 가능하게 하는 함수이다. 특정 조건이 차밀 때만 해당 템플릿을 활성화하고 그렇지 않을 경우 템플릿을 비활성화 한다. 
template<class T>
struct enable_if<bool, T> {};
위와 같이 사용하며 bool자리에 true가 들어가야 뒤의 부분을 정의하고 그렇지 않으면 정의 되지 않는 방식으로 템플릿 함수들의 무분별한 오버로딩을 제어할 수 있다. 단 enable_if 를 사용한다면 함수의 선언 부분과 리턴 타입을 쉽게 알아보기 힘들 것이다.





confluence - IPC(Inter-Process Communication)

Process가 동작할 때 할당 받게 되는 가상 메모리는 보통 4기가이다. 이중에 User Space로 구현된 코드를 통해 할당받는 Stack,Heap 등 메모리가 여기에 할당되며 나머지 1기가는 Kernel이 사용하는 영역이다. Kernel Space는 Kernel이 사용하는 영역이기 때문에 Kernel은 Kernel Space를 공유할 수 있으나 User는 이 영역에 접근할 수 없다. 또한 User Space의 메모리는 Process 간 공유 되지 않는 것이 특징이다. 따라서 Process간 데이터를 주고 받는 등 통신을 하기 위해서는 Kernel의 도움이 필요하다.

Socket(Unix Domain Socket)
IPC socket이라고 하며 TCP의 소켓과 동일한 API로 데이터를 주고 받을 수 있는 local file 기반의 소켓입니다. TCP socket과의 차이점은 local host의 process간의 통신이므로 속도가 매우 빠르고 메모리 소모가 적다는 장점이 있다. sockaddr_un이라는 구조체를 사용하는 것 외에는 일반적인 소켓을 다루는 것과 동일하므로 UDS로 구성해 놓은 후에 성능이나 보안상의 문제로 서버를 클라이언트와 분리하기가 매우 용이하다. 

Pipe
Pipe 통신은 소켓 통신과 마찬가지로 프로세스에 속하는 자원이 아니다. 운영체제가 마련해주는 메모리 공간을 통해서 두 프로세스는 통신을 한다. 양방향 방식을 지원하는 시스템도 있으나 일반적으로는 단방향 방식이 다양한 플렛폼에서 사용이 가능하다. 단, 부모 자식 관계의 프로세서들만이 사용가능하며 데이터는 FIFO순서로 전달된다.

Shared memory
하나의 프로세서가 다른 프로세서가 접근 가능한 영역을 RAM 위에 생성하여 프로세서간 데이터를 동시에 교환할 수 있게하는 IPC로 사용한다. 파일 시스템을 사용하는 파이프나 Unix Domain Socket과 다르게 프로세서들이 일반적으로 사용한느 메모리처럼 공유 메모리 영역에 접근하기 때문에 매우 빠른 IPC 방법이다. 당연 동일한 물리 메모리를 사용하는 경우에만 사용할 수 있으므로 Shared memory를 통한 IPC는 프로세서들이 하나의 컴퓨터 안에서 돌아갈 때만 사용할 수 있다.
