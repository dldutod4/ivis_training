6월 3일 월요일

C++토막글. Rvalue 레퍼런스에 관해

우측값 참조를 통해 move(데이터의 이동, 메모리 주소 간의 데이터 복사, 객체의 리소스를 다른 객체로 이동)의 구현과 완벽한 전달 문제를 해결할 수 있다.
좌측값은 대입 시에 왼쪽 혹은 오른 쪽에 오는 (변수나 표현식 같은)식이고 우측값은 대입시에 오직 오른쪽에 오는 (실수값이나 문자 같은)식이다.
좌측값은 어떠한 메모리 위치를 가르키기 때문에 연산자 &를 통해서 그 위치를 참조할 수 있으나 우측값은 좌측값처럼 실제 메모리 위치를 갖지 않아 연산자 &를 통해 메모리 위치를 참조할 수 없는 나머지 값이라 생각하면된다.
X를 생성, 복사, 소멸하는데 시간이 많이 걸리는 어떠한 리소스(크기가 큰? 리소르)에 대한 포인터를 담고 있는 클래스라고 가정해보자. 여기서 복사 대입 연산자 =를 직접 구현을 아래와 같이 한다.
X& X::operator=(X const& rhs) {
  // m_pResource 가 가리키는 리소스를 소멸한다.
  // rhs.m_pResource 의 복제된 버전을 생성한다.
  // m_pResource 가 복제된 버전을 가리키게 한다
}
X foo();
X x;
x = foo();
위와 같이 대입 연산자 =를 사용하면 X객체 x가 갖고 있는 리소스가 소멸하고 foo()가 반환한 임시 객체의 리소스의 복제본이 생성된 후에 x가 복제된 리소스를 가리키고, 임시로 생성된 객체의 리소스는 소멸되는 3단계를 커지고 불필요한 임시 객체의 리소스 복제본을 만든다. 하지만 단순하게 생각하면 굳이 임시로 생성된 객체의 리소스 복사본을 만들 필요 없이 바로 임시 생성된 객체의 m_pResource를 X의 m_pResource와 서로 교환만 해주면 위의 과정과 동일한 결과를 얻을 수 있다.
따라서 X& X::operator=(<미지의 타입> const& rhs) {// m_pResource 와 rhs.m_pResource 를 교환}와 같이 구성하는 것을 move 연산이라고 한다. 여기서 미지의 타입이 지켜야 할 것은 기존의 레퍼런스 &와 차별화를 두어서 미지의 타입과 보통의 레퍼런스 타입을 사용한 두 함수 사이에서 촤측값의 경우 보통의 레퍼런스 타입을 우측값의 경우 미지의 타입을 택하도록 만들어야하고 이 미지의 타입에 우측값 참조라는 이름을 C++ 개발자들이 붙였다.

우측값 참조
임의의 타입 X에 대해 X&&를 X의 우측값 참조라고 정의한다. 기존의 레퍼런스 X&를 좌측값 참조라고 부른다. 우측값 참조는 기존의 레퍼런스 X&와 몇 가지 예외를 제외하고는 유사하게 작동합니다. 단 함수 오버로딩에서 좌측값은 좌측값 레퍼런스를, 우측값은 우측값 레퍼런스를 선호하기에 위쪽의 직접 구현 대입 연산자 오버로딩에서 처럼 사용해 주어야한다. 따라서 우측값 참조는 컴파일러로 하여금 컴파일 시에 자신의 인자로 좌측값이 오는지, 우측값이 오는지에 따라 오버로딩을 할 수 있도록 도와준다고 볼 수 있다. 어떠한 함수라도 인자로 우측값을 받도록 할 수 있지만 대다수의 경우 move 연산을 위해서는 우측값 참조로 인자를 받는 경우는 복사 생성자나 대입 연산자들 밖에 없다. 다만 대입 연산자를 직접 구현할 때 단순히 swap하는 것만으로 충분하지 않다.

강제적으로 move하기
C++은 move 연산을 우측값에만 제공하는 것이 아니라 좌측값에서도 사용할 수 있다. 예를 들어 좌측값 a, b를 a에는 b를 b에는 a를 넣어서 서로 바꿔야할 때 기존에는 temp에 a를 전부 복사한 후 a에 b를 전부 복사해서 넣고 다시 b에 temp 넣는 방식으로 복사를 3번하는 방식으로 진행했다면 자유도 높은 C++에서 move를 사용하여 temp에 복사 대신 a를 이동시키고 a에 b를 이동하고 마지막으로 b에 temp를 이동하는 move를 3번 사용하면 여러번의 복사없이 a, b를 swap할 수 있다. 이러한 move를 사용한 swap은 내부 정렬 알고리즘 같이 수 많은 swap을 진행하는 알고리즘에서 매우 높은 성능 향상을 기대할 수 있다. 또한 STL에서 많은 경우 특정 타입의 복사 기능을 요구 하였지만 많은 경우 굳이 복사 보단 move 하는 정도로 충분하다는 것이 밝혀져 STL 성능 향상에도 move는 많은 기여를 했다. 

우측값 참조는 우측값 인가?
우측값 참조라 정의한 것들도 좌측값 혹은 우측값이 될 수 있다. 이를 판단하는 기준은 이름이 있다면 좌측값, 없다면 우측값이다. C++은 move 연산으 오직 사용해도 상관없는 곳에서만 사용하도록 되어 있기 때문에(이동 즉시 소멸되어서 접근 불가능한 경우가 생긴다.) 이름이 있다면 좌측값으로 정의한다. 반대로 이름이 없다면 우측값이다라는 정의를 이용해서 좌측값에 대해서 강제적(이름을 가려서)으로 move연산을 수행 시킬 수 있다.

Move 연산과 컴파일러 최적화
현대의 컴파일러들은 리턴값 최적화라는 작업을 통해서 x를 생성한 뒤에 리턴값에 복사하는 것이 아니라 x 자체를 함수의 리턴값 부분에 생성한다. 이러한 이유로 어떠한 함수 return 부분에 move연산을 사용하게된다면 x를 전부 생성하고 진행한 뒤에 move를 하기 때문에 오히려 수행 시간이 늘어난다. 따라서 move를 사용하기 위해서는 현대의 컴파일러의 여러가지 기법들(리턴갑 최적화, 복사 생략 등)을 어느 정도 알고 있어야한다.

완벽한 전달
template <typename T, typename Arg>
shared_ptr<T> factory(Arg arg) {return shared_ptr<T>(new T(arg));}
위의 경우 인자 arg를 T의 생성자에게 전달하고자 한다. 인자 arg가 마치 factory함수 없이 직접 완벽하게 전달되는 것을 목표로한다. 하지만 factory 함수는 call-by-value(함수가 호출될 때 인수로 전달된 값의 복사본이 함수에 전달되는 방식, 원래 변수에는 영향을 미치지 않음)를 하기 때문에 위의 코드를 성공적으로 수행할 수 없다. 이를 해결하기 위한 일반적인 방법은 바깥의 함수가 인자를 레퍼런스로 가지게 하면되지만(Arg arg대신 Arg& arg) 이럴 경우 우측값에 대해 성공적으로 호출되지 않는다. 우측값도 성공적으로 호출하기 위해 const를 붙인다 해도 const와 non-const 참조 인자들의 모든 조합들에 대해 오버로드 함수를 제공해야하는 불편함을 격게된다. 이런 문제들은 우측값 참조를 통해 오버로드 없이도 완벽한 전달 문제를 해결할 수 있다.

완벽한 전달 문제 해결책
template <typename T>
void foo(T&&);
위의 경우에 foo가 A의 좌측값으로 호출된다면 T는 A&로 변환되고 인자 타입은 A &가 된다. foo가 A의 우측값으로 호출된다면 T는 A로 변환되고 위의 & 겹침 규칙에 따라 인자 타입은 A&&가 된다. 따라서 좌측값을 인자로 받나 우측값을 인자로 받나 하나의 함수로 모두 대응이 가능해진다.

std::move는 레퍼런스로 받은 인자를 우측값처럼 행동하게 하는 것이다. 좌측값 X에 대해 아래와 같이 std::move를 호출했다고 가정하자.
X x;
std::move(x);
특수 템플릿 인자 유추 규칙에 따라서 템플릿 인자 T는 X&로 바꾸고 좌측값 x는 인자인 좌측값 참조를 통해 인자로 전달되어서 이름 없는 우변값 참조로 변환된다. 좌측값 x을 우측값으로 바꿀때 static_cast<X&&>(x)를 사용할 수도 있지만 move가 훨씬 간편하고 깔끔하다.

암시적 Move
과거에는 우측값 참조를 사용하는 복사 생성자와 복사 대입 연산자들을 사용자가 제공하지 않는다면 컴파일러가 스스로 제공하도록 되어있다.하지만 컴파일러가 제공하는 move 생성자가 원래의 코드를 심각하게 손상 시킬 수 있다는 것이 밝혀졌다. 현재는 기존 방식으로 move 생성자와 move 대입 연산자들을 컴파일러가 생성하는 것을 제한하고 코드를 손상시키는 것이 거의 불가능하도록 변경하였다. 위의 경우처럼 암시적 move는 계속해서 논쟁 거리로 남아있으나 암시적 move를 도입한 이유가 우측값 문제와 예외 처리이기 때문에 못 쓰게 할 수는 없고 대신 noexcept 키워드를 도입하여 컴파일러가 제공하는 암시적 move는 사라지고 문제를 해결할 수 있게 되었다.




Valgrind
Valgrind는 동적 분석을 위한 리눅스 기반의 오픈 소스 dynamic instrucmentation framework이다. instrumentation은 코드 세그먼트에서 코드에 필요한 내용을 추가하여 원하는 결과를 내도록 하는 작업을 통틀어 말한다. static instrumentation의 경우 실행 중 발생하는 상황을 알 수 없지만 valgrind와 같은 dynamic instrumentation의 경우 runtime에 instrumentation을 수행하여 메모리나 캐시의 동작을 관찰할 수 있다.
valgrind의 core는 tool들이 instrumentation 할 수 있는 환경을 제공한다. 각 tool들은 특정한 현상 분석을 위한 instrumented될 코드들을 포함한다. 사용가능한 툴 목록은 man valgrind로 확인 할 수 있다.
memcheck : 메모리 관리 문제를 감지
cachegrind : 캐시 관리 툴 
callgrind : cachegrind가 제공하는 모든 정보를 제공하고 추가로 callgrahps를 제공한다. 프로파일링하기 위한 툴이며 함수가 얼마나 효율적으로 동작하고 있는지, 어떤 함수가 오래 걸리고 어떤 함수의 어떤 부분이 개선되어야하는지 알수 있다.
helgrind : 멀티쓰레트 프로그램에서 race 관련 문제를 찾기위한 디버거이다.
drd : podix 쓰레딩을 사용하는 멀티 쓰레드 프로그램에서 에러를 감지한다. podix란 pod기반의 프레임워크로, 멀티쓰레디을 보다 쉽게 구현할 수 있도록 도와주는 도구이며 Go언어로 작성되어, 성능과 확장성을 고려하여 설계되었다. podix의 멀티쓰레딩 개념은 전통적인 쓰레드와는 약간 다른 방식으로 동작한다. podix는 Go언어의 goroutine과 비슷한 개념을 제공하면서 더 높은 수준의 추상화를 통해 멀티스레딩 작업을 쉽게 구현할 수 있도록 도와주며 성능과 확장성이 좋다. drd는 helgrind 처럼 locking order violations(여러 쓰레드가 다양한 락을 서로 다른 순서로 획득할 때 발생하는 데드락 같은 문제)을 찾을 수는 없지만 더 적은 메모리로 분석이 가능하다.
massif: heap분석툴
sgcheck: 스택 및 전역 배열에서 overruns를 찾을 수 있는 툴
bbv: SimPoint 분석(프로그램의 성능을 평가하기 위해 사용되는 기술, 프로그램 전체를 시뮬레이션하는 대신, 프로그램의 실행 중 일부 대표적인 부분을 선택하여 시뮬레이션하여 시간을 절약하고 효율성은 높이는 분석 기법) tool과 사용되는 basic block vector를 생성하는 툴. basic block은 하나의 진입점과 하나의 종료점이 있는 코드 섹션이며 baisc block vector는 프로그램 실행중 진입한 모든 basic block의 리스트와 각 block이 실행된 횟수이다.
lackey : 많이 사용되지 않으며 테스트 및 시연 목적으로 사용된다.

--vgdb=<no|yes|full> [default: yes]
valgrind가 gdbserver를 제공한다. 이를 통해 GNU GDB 디버거가 프로그램을 제어하고 디버그 할 수 있다. --vgdb=full 옵션은 큰 오버헤드를 발생시키지만 보다 정확한 breakpoints와 watchpoints를 제공한다.

--vgdb-error=<number>[default:999999999]
<number>의 에러가 발생하면 gdb server를 실행시킨다.

HEAP SUMMARY
in use at exit : 프로그램 종료 시점에 값이 남아있는 메모리 크기/블록이다. LEAK SUMMARY에 모든 값을 더한 값이다.
total heap usage : 메모리 할당 해제를 몇번 했는지, 총 할당한 메모리. allocs와 frees의 갯수가 같은 것이 좋다.

LEAK SUMMARY
definitely lost : 힙 할당 메모리의 포인터가 없어서 해제될 수 없을 경우, 반드시 수정되어야 한다.
indirectly lost : 포인터 기반 structure에 누수가 있는 경우. definitely lost를 수정하면 같이 사라져야한다
possibly lost : valgrind가 힙 할당 메모리의 해제 여부를 알 수 없는 경우. 일반적인 포인터 작업으로는 메모리 누수가 발생하기 때문에 수정하는 것이 좋다.
still reachable : 프로그램 종료시 포인터가 해제되지 않은 힙 할당 메모리이다. 정상범주에 속하기 때무에 일반적으로 수정할 필요가 없다.
suppressed : 억제된 메모리 릭이 있음

Callgrind
callgrind와 cachegrind의 경우 분석을 좀더 쉽게 할 수 있게 도와주는 gui tool도 있으니 설치해서 사용하면 좋다. callgrind를 실행하면 callgrind.out.xxxx 파일을 생성하는데 KCachegrind를 통해 분석할 수 있다.

Helgrind
helgrind의 경우 thread가 많을 때 오랜 시간이 걸리고 로그 또한 많이 나오기 때문에 로그를 file에 따로 저장하는 것이 좋다.
helgrind의 경우 command-line-option을 특별히 조절하지 않아도 일반적인 이슈를 분석할 수 있다.

Massif
Massif는  callgrind와 cachegrind 같이 분석을 좀 더 쉽게 할수 있게 도와주는 gui tool이 있다. command-line option을 통해 스냅샷의 최대값 유닛 정확도 등을 설정할 수 있다. massif를 실행하면 massif.out.xxxx 파일이 생성되고 massif-visualizer를 통해 분석할 수 있다.
