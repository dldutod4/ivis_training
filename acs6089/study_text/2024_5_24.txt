5월 24일 금요일

금일은 15-3까지를 목표로 진행하겠습니다.


13-2. 자원을 공유할 때 - shared_ptr 와 weak_ptr

대부분의 경우 하나의 자원은 한 개의 스마트 포인터에 의해 소유되는 것이 바람직하지만 때에 따라서 여러 개의 스마트 포인터가 하나의 객체를 같이 소유해야하는 경우가 발생한다. 이 하나의 자원을 모두 사용한 이후에 이 자원을 사용하는 모든 객체들이 소멸되어야 하는데 어떤 객체가 먼저 소멸되는지 알 수 없기 떄문에 이 자원 역시 어느 타이밍에 해제 시켜야 할 지 알 수 없게 됩니다. 그렇기에 특정 자원을 몇 개의 객체에서 가르키는지 추적한 다음에 그 수가 0이 되면 비로소 해제하는 방식의 포인터가 shared_ptr이다. 이렇게 어떤 객체가 shared_ptr 로 부터 가르킴을 받는 갯수를 참조 개수(reference count)라고 하고 이것이 0이 되어야지만 해당 객체를 해제할 수 있다.

shared_ptr은 하나의 객체를 여러 포인터가 가리키는 형태로 운영된다. 이 경우 새로운 shared_ptr이 이미 여러 개의 shared_ptr이 가르키고 있는 객체에 추가적으로 가르키게 될 경우 늘어난 참조 갯수를 다른 shared_ptr들에게도 동기화할 필요가 있다. 이런 상황에서 동기화를 위해 shared_ptr는 제어 블록(control block)을 따로 동적으로 할당한 후, shared_ptr들이 이 제어 블록에 필요한 정보를 공유하는 방식으로 동기화를 한다. 

std::shared_ptr<A> p1(new A());
위와 같은 겨우 A를 생성하면서 1번의 동적 할당이 일어나고, shared_ptr의 제어 블록을 생성하면 또 1번의 동적 할당이 일어나는 총 2번의 동적 할당이 따로 일어나는 형태로 사용된 경우이다. 하지만 위의 경우 2번의 동적 할당이 일어남이 명확하기 때문에 이 2번의 동적 할당을 1번에하고 대신 그 크기를 2번의 동적 할당에 배정될 크기로 1번에 동적 할당을 하면된다. 따라서 위와 달리 아래와 같이 make_shared을 사용하면 동적 할당의 횟수를 줄일 수 있다.
std::shared_ptr<A> p1 = std::make_shared<A>();

* shared_ptr은 인자로 주소값이 전달되면 여러 shared_ptr이 이미 해당 객체를 가르키고 있어도 해당 객체를 첫번째로 소유하는 것으로 인식하고 행동한다. 따라서 각각의 제어 블록을 따로 가지게되고 어느 한쪽에서 shared_ptr을 해제하며 참조 개수가 0으로 바뀌어 해당 주소의 객체를 지워버리면 다른 한쪽은 더 이상 접근할 수 없게 된다. 따라서 shared_ptr를 주소값을 통해서 생성하는것을 지양해야한다. * 하지만 주소값으로 shared_ptr을 생성해야한다면 enable_shared_from_this 클래스를 이용하여 생성하면 좋다. 해당 클래스는 shared_from_this 라는 맴버 함수가 존재하는데 이 함수는 이미 정의되어 있는 제어 블록을 사용해서 shared_ptr을 생성하여 같은 객체에 두개의 다른 제어 블록이 생성되는 일을 막을 수 있다. 딴 shared_from_this가 원활히 작동하기 위해서는 해당 객체의 shared_ptr가 반드시 먼저 정의되어 있어야한다.

shared_ptr이 서로를 참조할 경우
객체 1이 shared_ptr_1을 가지고 이 포인터가 객체 2를 가르키고 있고 객체 2는 shared_ptr_2를 가지며 이 포인터가 객채 1을 가르키고 있으면 서로를 참조하고 있는 형태이다. 여기서 객체 1을 삭제할려면 객체 1이 가지고 있는 shared_ptr_1의 참조 개수가 0이 되어야하고 그러기 위해서는 객체 2를 삭제해야한다. 하지만 객체 2의 내부에 있는 shared_ptr_2가 객체 1을 가르키고 있고 참조 개수가 1이라 함부로 파괴 되지않는 상태에 빠지게 된다. 이러한 순환 참조일 경우 shared_ptr로는 해당 문제를 해결할 수 없고 weak_ptr을 사용해야한다.

weak_ptr
weak_ptr을 이해하기 위해서는 트리형태의 클래스를 생각하면 된다. 부모 노드는 여러개의 자식 노드를 가질 수 있지만 자식 노드는 한 개의 부모 노드만을 가질 때, 부모 노드는 자식 노드들을 가르키고 자식 노드는 부모 노드를 가르키는 순환 참조의 경우가 생긴다. 이러한 클래스 구조에 shared_ptr을 사용하면 각 shared_ptr의 참조 개수가 절대로 0이 될 수 없으므로 프로그램이 끝날때까지 해당 클래스는 남아있게된다. 이럴때 일반 포인터와 shared_ptr의 사이에 있는 weak_ptr 스마트 포인터를 사용하여 안전하게 참조할 수 있지만 shared_ptr 와는 다르게 참조 개수를 늘리지 않는다. weak_ptr 단독으로는 원래 객체를 참조할 수 없고 반드시 shared_ptr로 변환해서 사용해야한다.
weak_ptr에 정의된 lock 함수는 weak_ptr이 가르키는 객체가 아직 메모리에 살아 있다면 해당 객체를 가르키는 shared_ptr을 반환 하고 이미 해제가 되었다면 shared_ptr을 반환한다.



14. 함수를 객체로! (C++ std::function, std::mem_fn, std::bind)

Callable이란 호출 가능한 모든 것을 포괄해서 나타내는 것이다. 
모든 Callable들을 객체 형태로 보관할 수 있는 std::function이 존재한다.
function 객체는 템플릿 인자로 전달 받을 함수의 리턴값과 입력 인자값의 타입을 받는다.
functor 인 클래스 객체의 경우 단순히 해당 객체를 그대로 전달해도 함수 인양 function 함수가 받을 수 있다.
맴버 함수 내에서 this의 경우 자신을 호출한 객체를 의미하기 때문에, 맴버 함수를 그냥 function에 넣게 된다면 this가 무엇이지 알 수 없는 문제가 발생하게 됩니다. 맴버 함수들은 구현 상 자신을 호출한 객체를 인자로 암묵적으로 받고 있다. ex)파이썬에서 def func(self)로 사용하는 것을 보면 알 수 있다.
따라서 맴버 함수들의 경우 function을 쓸 시에 원래 인자에 추가적으로 객체를 받는 인자를 전달해 주어 사용면 this가 무엇인지 알 수 없는 문제가 해결된다.
맴버 함수가 아닌 모든 함수들의 경우 이름이 함수의 주소값으로 암시적으로 변환이 일어나지만, 맴버 함수들의 경우 암시적인 변환이 발생하지 않으므로 & 연산자를 통해서 명시적으로 주소값을 전달해줘야 한다.
매번 function 객체를 따로 만들어 전달하는 것은 비효율적이기때문에 mem_fn 함수로 한 번에 function 객체로 만들어 리턴해 준다.

함수 객체 생성 시에 인자를 특정한 것으로 지정할 필요가 있을 시에 bind 함수를 사용하면 된다.




15-1. 동시에 실행을 시킨다고? - C++ 쓰레드(thread)

CPU는 한번에 한가지의 작업만 수행할 수 있다.하지만 우리가 싱글 코어 컴퓨터를 쓸적에도 음악을 들으며 동시에 인터넷도 사용했었다. 이것이 가능한 이유는 여러 프로그램을 빠르게 번갈아 가면서 CPU가 하나씩 수행하는 컨텍스트 스위칭을 통해서 가능하게 하였다. CPU는 운영체제가 시키는 작업을 수행할 뿐 실제 컨텍스트 스위칭은 운영체제의 스케줄러가 결정하여 CPU에게 명령을 수행시키게 하는 것이다. 프로세서끼리는 메모리를 공유하지 않는다. 쓰레드의 경우 같은 프로그램 내부에 있다면 메모리를 공유한다.
어떤 작업을 여러개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 병렬화라고 한다. 의존 관계에 잇는 프로그램은 병렬화가 매우 어렵다. 반대로 독립적으로 수행할 수 잇는 구조가 많을 수록 병렬화가 매우 쉽다.

C++에서 pthread_create를 이용하여 새로운 thread를 생성한다. 해당 쓰레드 들이 CPU 코어에 어떻게 할당되고, 언제 컨텍스트 스위치를 할 지는 전적으로 운영체제의 마음에 달려있다. 메인 프로세스가 종료될때 하위의 쓰레드들이 작동 중이여도 종료되기 때문에 해당 하위 쓰레드들이 끝까지 수행할 필요가 있을 시 해당 쓰레드들이 실행을 종료하면 리턴을 하는 함수 join을 사용하여 쓰레드가 종료되지 않으면 프로세서도 종료하지 않게 해주면 된다. 또한 해당 쓰레드가 잘 도는 지 확인할 필요가 없을 시 해당 쓰레드를 잊어버리는 detach라는 함수를 사용한다. detach 함수를 사용하면 프로세서가 종료될때 알아서 같이 종료된다. std::cout 라이브러리는 내용이 출력되는 동안 다른 쓰레드가 내용을 출력할 수 없게 보장해준다.

여러 쓰레드들이 하나의 변수에 아무런 제약 없이 접근할 시 원하는 결과가 나오지 않을 수도있다. 




15-2. C++ 뮤텍스(mutex) 와 조건 변수(condition variable)

서로 다른 쓰레드에서 같은 메모리를 공유할 때 동일한 자원에 접근하면 발생하는 문제를 경쟁 상태라고 한다.
CPU는 연산을 할 때 레지스터라는 CPU내부의 매우 빠르나 작은 저장 공간을 활용한다. 따라서 연산을 할 때 메모리에서 변수를 가져와 레지스터에 넣어둔 다음에 CPU에서 레지스터의 값을 연산하고 그 연산된 값을 다시 메모리에 저장하는데 여기서 문제가 발생한다. 같은 메모리 공간에 있는 변수를 쓰레드 1,2가 코어1,2를 각각 사용해 처리할 경우, 변수가 있는 메모리 공간에서 쓰레드 1,2가 같은 값을 각각 코어의 레지스터로 복사한다. 그후 각각의 쓰레드가 연산을 마치고 각각의 연산 결과를 같은 메모리 위에 올리게 되면 먼저 나중에 처리가 끝난 쪽의 정보로 씌워지게 된다. 쓰레드 1,2가 번갈아가며 counter값을 증가 시켜야할때 각 쓰레드 내부의 레지스터의 값에 증가 연산을 하게 되므로 원하는 결과가 안 나올수도 있다.

위와 같이 하나의 객체를 여러 쓰레드가 동시에 사용할 경우 문제가 생길 수 있어 하나의 쓰레드가 여러 쓰레드가 공유하는 객체를 사용 중일때 다른 쓰레드가 접근하는 것을 막을 때 mutex를 사용한다. lock함수는 해당 쓰레드가 mutex 객체를 단독으로 쓰게고 다른 쓰레드의 접근을 막는 함수이다. unlock 함수는 독점적으로 사용하던 mutex 객체를 다른 쓰레드도 접근 가능하게 해준다. 이렇게 하나의 쓰레드가 mutex 객체를 유일하게 실행할 수 있는 코드 부분을 임계 영역이라 한다.
여기서 주의할 점은 lock을 하였으면 꼭 unlock을 해주어야한다. lock을 하고 풀어주지 않아 계속 아무런 작업도 하지 못하는 상황을 deadlock이라 한다.
deadlock 문제의 경우 디버깅이 어렵기때문에 모든 쓰레드들이 최대 1개의 lock만 소유하거나 여러개의 lock을 사용해야할 시 반드시 이 lock들을 정해진 순서로 획득해야한다.

생산자는 무언가 처리할 일을 받아오는 쓰레드를 의미한다. 소비자의 경우 받는 일을 처리하는 쓰레드를 의미한다.
예를 들어 어느 웹사이트를 계속 끌어오는 프로그램을 보면 웹사이트 페이지를 계속 다운로드 하는 역활을 하는 쓰레드가 생산자 쓰레드이고 다운로드된 웹페이지를 처리하는 쓰레드가 소비자이라고 볼 수 있다. 여기서 다운로드를 하는 생산자가 느릴 경우 다운로드를 처리하는 소비자를 대기 시킬때 내부에 그냥 while문으로 돌리며 일정 시간마다 처리할 일이 들어왔는지 확인시키는 방식으로 대기시키면(폴링?) 의미 없는 while문을 돌면서 자원을 차지하는 꼴이 된다. 이것을 해결하고자 처리할 일이 없을 시 소비자 쓰레드를 재워두웠다가 처리할 일이 생길때만 생산자가 직접 소비자를 깨우는 방식(인터럽트?)을 condition_variable 이라는 변수를 통해서 C++에서 지원한다. 이렇게 쓰레드를 잠재우는 함수 중에 wait는 condition_variable이 활성화될때까지 대기시키고 wait_for는 condition_variable이 활성화되거나 특정 시간 동안 대기시키고 wait_until은 condition_variable이 활성화 되거나 특정 시각에 도달할때까지 대기시키는 함수이다.




15-3. C++ memory order 와 atomic 객체

memory는 생각보다 CPU보다 많이 느린 장치이다. CPU가 1 사이클에 1번의 행동을 할 수 있다고 보면 i7 6700을 기준으로 memory에서 데이터를 불러오는데 42사이클이 소요된다. 그래서 이 긴 공백기를 채우기 위해 CPU와 memory사이에 cache라는 매우 바른 저장공간이 있다. L1 cache의 경우 데이터를 읽거나 쓰는 경우 4 사이클만이 소요된다. 따라서 자주 쓰는 데이터를 cache 넣고 사용하면 memory까지 가서 불러오는 것에 비해 많은 사이클 또는 시간을 절약할 수 있다.

실제 CPU에서 명령어를 실행할 때 여러 단계를 거치게된다. 명령어를 읽는 fetch, 명령어를 해석하는 decode, 명령어를 실행하는 execute, 실행한 명령어를 쓰는 write 등으로 구분된다. 한 명령어에 대해 CPU가 위의 과정을 하나씩 처리하게된다면 4사이클이 소비된다. 하지만 각 과정이 독립적이라 각 과정을 파이프라인에 넣고 독립적으로 시행하게되면 첫 명령어가 시행될때까지는 똑같이 4사이클이 소비되겠지만 그 후에 오는 명령어들은 1사이클내로 시행이 될 수 있다.

따라서 실제로 C++로 코딩을 하더라도 컴퓨터 구조상 위의 다양한 경우에 의해서 더 빠르게 작동하게 할 수 있다. 따라서 컴파일러가 명령어를 최대한 효율적으로 시행할 수 있게 우리가 짠 코드와 다르게 컴파일링 할 수도 있다.

만약에 어떤 객체의 값을 실시간으로 확인할 수 있다고 할때 해당 객체의 값의 변화를 기록한 것을 수정 순서라고 한다. * 모든 쓰레드에서 변수의 수정 순서에 동의만 한다면 같은 시간에 변수를 관찰했다 할지라도 궅이 모든 쓰레드들이 동일한 값을 관찰할 필요는 없다. * 쉽게 말해서 실행하는 순서는 달라도 결과만 같다면 아무런 문제가 되지 않는다.

CPU가 명령어 1개로 처리하는 명령, 즉 다른 쓰레드가 끼어들 여지가 컴퓨터 구조상으로 전혀 없는 연산을 원자적 연산이라 한다. 몇몇 타입의들에 원자적인 연산을 할 수 있도록 지원하는 atomic이라는 함수가 있다.

atomic 객체 들의 경우 원자적 연산 시에 메모리에 접근할 때 어떠한 방식으로 memory에 접근하지 지정할 수 있다. memory_order_relaxed는 가장 느슨하게 메모리에서 읽거나 쓸 수 있다. memory_order_release는 해당 명령 이전의 모든 메모리 명령들이 해당 명령 이후로 재배치 되는 것을 금지. memory_order_acquire는 해당 명령 뒤에 오는 모든 메모리 명령들이 해당 명령 위로 재배치 되는것을 금지, memory_order_acq_rel은 release와 acquire을 모두 수행, memory_order_seq_cst 메모리 명령의 순차적 일관성을 보장한다. 일반적인 ++ 연산자는 fetch_add(1, memory_order_seq_cst)와 동일하다. 인텔이나 AMD같은 x86 CPU의 경우 거의 순차적 일관성이 보장되어 memory_order_seq_cst가 그렇게 큰 부담이 되지 않지만 ARM계열의 CPU는 순차적 일관성을 보장하기 위해서 CPU 동기화를 위해서 많은 자원을 사용하기에 주의해서 사용하자.
