5월 21일 화요일 

6-3. 가상함수와 상속에 관련한 잡다한 내용들

virtual 소멸자
상속 시에 소멸자를 가상함수로 만들어야한다. 만약 제대로 소멸자를 호출하지 않으면 메모리 누수 문제가 발생할 수 있다.
상속 시에 기본 클래스 생성자 -> 파생 클래스 생성자 순으로 호출도니 소멸자는 
파생 클래스 소멸자 -> 기본 클래스 생성자 순으로 호출해야한다.

파생 클래스에서 소멸자를 호출 할 때 기본 클래스의 소멸자도 호출해주면 자동으로 둘다 소멸한다. 따라서 상속될 여지가 있는 클래스에는 반드시 virtual로 소멸자를 만들어 주어야한다.

기반 클래스에서 파생 클래스에 접근할 때 기반 클래스의 포인터를 통해 접근하는 법도 있지만 기반 클래스의 래퍼런스로도 접근이 가능하다.
모든 함수를 가상함수로 만들어도 되지만 가상 함수를 사용하면 약간의 오버헤드(함수를 호출하는데 걸리는 시간)가 발생한다.
가상 함수가 하나라도 존재하면 가상 함수 테이블이 생성된다. 이 가상 함수 테이블은 모든 가상 함수에대 어떤 함수인지 주소나 전화번호부 같이 저장하고 호출시 적절한 함수를 호출해준다.따라서 어떤 가상 함수를 호출하면 일반적인 함수들과 달리 가상 함수 테이블을 한번 거치기때문에 일반적인 함수들보다 한단계 더 필요하고 시간이 더 걸리게 된다.

순수 가상 함수(pure virtual function), 추상 클래스(abstract class)
순수 가상 함수란 가상 함수에 = 0을 붙여서 실제 작동하지 않고 반드시 작동을 위해 오버라이딩 되어야만 하는 함수이다.
추상 클래스란 순수 가상 함술르 최소 한개 포함하고 반드시 상속 되어야 하는 클래스이다.

다중 상속(multiple inheritance)
한 클래스가 여러 개의 클래스들을 상속 받으면 다중 상속이라 한다.
다중 상속 시 기반 클래스들에 같은 명의 변수나 함수가 있을 수 있는데 이를 호출 시 문제가 발생할 수 있고 이를 다이아몬드 상속(diamond inheritance)이라한다.
위와 같은 문제를 해결하기 위해 virtual로 상속을 받아 한번만 호출하도록 하는 방법이 있다.
다중 상속은 각 카테고리에 해당하는 파생 클래스들을 만들고 각각의 환경에 해당하는 클래스를 상속받는 파생 클래스들을 n*m개 만들어 사용한다.
중첩된 일반화 방식은 한 가지 계층을 먼저 골라서 파생 클래스들을 생서한다.
브리지 패턴은 한 가지 카테고리를 맴버 포인터로 만들어 새로운 카테고리가 생기면 클래스를 1개더 만드는 방식으로 사용해 n+m개의 클래스만을 생성한다.



7-1. C++에서의 입출력(istream, ostream)

C++의 모든 입출력 클래스는 ios_base를 기반 클래스로 한다. ios_base 클래스는 스트림 입출력 형식 관련 데이털르 처리한다. ios 클래스 또한 사용되는데 해당 클래스는 스트림 버퍼를 초기화한다. eof : 파일의 끝을 판독하는 함수, good : 입출력을 잘 수행할 수 있는지 확인하는 함수

istream 클래스
해당 클래스는 실제 입출력을 수행하는 클래스, 해당 클래스의 입출력을 보조하는 ios 클래스에서 현재의 스트림 상태를 관리하는 4개의 플래그각 존재한다. goodbit(스트림 입출력 작업 가능 여부), badbit(스트림 복구 불가능 오류 발생 여부), failbit(스트림 복구 가능 오류 발생 여부), eofbit(입력 작업시 파일 끝 도달 여부)의 4개의 플래그가 존재한다.

형식 플래그(format flag), 조작자(manipulator)
스트림 입출력 형식을 바꿀때 사용하는 플래그로 형식 플래그가 있다.
스트림을 조작하여 입력 혹은 출력 방식을 바꿔주는 함수를 조작자라고 한다.

스트림버퍼
모든 입출력 객체들은 이에 대응되는 스트림 객체를 가지고 있다. 대표적으로 C++의 입출력 라이브러리의 streambuf 클래스가 있다.
해당 클래스는 스트림의 상태를 나타내기 위해 3개의 포인터를 정의한다. 스트림의 시작부분을 가르키는 시작 포인터, 다음 으로 읽을 문자를 가르키는 포인터, 끝부분을 가르키는 포인터를 보유한다. 입력 버퍼는 get area, 출력 버퍼는 put area이다.



7-2. C++에서의 입출력(ifstream, ofstream, stringstream)

fstream
해당 스트림의 istream이나 ostream보다 많은 기능을 제공하기 때문에 해당 클래스들을 상속 받았다.
해당 스트림은 파일을 찾고 여는 is_open 함수, ifstream 객체 소멸시 자동으로 close하며, getline함수와 함께 istream에서 제공 사용한는 스트림 상태를 관리하는 4개의 버퍼들을 포괄하는 함수들을 사용한다.

파일 쓰기
ios::ate란 자동으로 파일 끝에서 부터 읽기와 쓰길르 실시
ios::trunc 파일 스트림을 열면 기존에 있던 내용들을 모두 지운다
ios::in, std::ios::out 파일에 입력 출력을 지정

std::stringstream은 sstream에는 std::istringstream이 정의되어 있는데 이는 마치 문자열을 하나의 스트림이라 생각하게 해주는 가상화 장치, 따라서 파일에서 읽어내는 것처럼 사용가능. 반대로 std::ostringstream은 데이터를 출력하는 함수를 사용할 수 있다.



8-1. Excel 만들기 프로젝트 1부

벡터(Vector) : 배열을 크기를 맘대로 조절할 수 있는 가변 배열
스택(Stack) : 항상 최상단의 데이터에만 접근 가능한 저장 배열(FILO)

벡터 클래스(vector)는 데이터 보관을 위한 data와 현재 크기를 알려주는 capacity, 현재 실제로 사용하는 양인 length로 구성된다.
스택 클래스(stack)의 스택의 경우 링크드 리스트를 사용하여 데이터를 보관 하기 때문에 별도의 Node 구조체를 사용, Node 구조체 내에는 다음 Node를 가르키는 prev와 자신의 데이터를 보관하는 s를 가지고 있다.

Cell 클래스는 엑셀에서 한 칸을 의미하는 객체로 해당 내용을 보관하는 data 와 테이블과 해당 칸의 위치 정보를 가지고 있는 table과 x,y로 구성된다.
Table 클래슨 각 Cell 객체들을 2차원 배열로 보관한다. 객체는 필요할 때 마다 동적으로 생성하고 그 객체에 대한 포인터를 2차원으로 보관한다.



8-2. Excel 만들기 프로젝트 2부

Cell 클래스는 데이터를 보관하는 data가 할당되어 있지만 문자열만 보관이 가능하기 때문에 더욱 확장된 새로운 클래스를 상속 받게하고 해당 클래스에 저장하자.

수식 계산하기, 중위 표기법과 후위 표기법
3+4*5+4*(7-2) 옆과 같은 숫자 사이에 기호를 넣어 표현하는 사람이 계산하는 법은 중위 표기법이다. 사람은 계산하지 편하지만 컴퓨터는 어려워 한다.
3 4 5 * + 4 7 2 - * + 옆과 같이 연산자들이 피연산자 뒤쪽에 있는 것과 괄호 없이 표현하는 것을 후위 표기법이라한다.
중위 표기법은 피연산자와 연산자 그리고 괄호를 이리저리 찾아가야하기에 컴퓨터가 계산하기 힘들다.
반면 후위 표기법은 피연산자를 만나면 스택에 push하고 연산자를 만나면 스택에 있는 두 개의 피연산자를 pop하여 해당 연산을 한 후 다시 스택에 push 하는 형태로 수식 계산이 가능하다.

중위 표기법을 후위 표기법으로 변환하기
하지만 일반적으로 우리가 수식을 입력할때 중위 표기법으로 입력하므로 해당 중위 표기법의 수식을 컴퓨터가 계산하기 편하게 후위 표기법으로 변환하여야한다.
피연산자일 경우 벡터에 집어 넣고 여는 괄호는 스택에 push한다. 닫는 괄호는 여는 괄호가 pop 될 때까지 pop 되는 연산자들을 피연산자를 집어 넣었던 벡터에 넣는다. 연산자일 경우 자기 보다 우선순위가 낮은 연산자가 스택 최상단에 올 때 까지 스택을 pop하고 pop된 연산자들을  벡터에 넣고 자신을 스택에 push한여 처리한다.



9-1. 코드를 찍어내는 틀 - C++ 템플릿(template)

기존에 사용하던 클래스에서 일부 자료형이나 함수만 바꿔서 사용할 필요가 있을때 사용자가 원한느 타임을 넣어주면 알아서 코드를 찍어내는 틀인 template이 존재한다.
ex) template <typename T>
class Vector
{
	T* data;
}
동일한 형태로 template <class T>를 사용하는데 위의 예시와 동일하게 작동한다.
컴파일러는 T의 자리에 typename에 해당하는 자료형을 넣어 클래스를 생성해준다.
위와 같이 클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화(class template instantiation)라고 한다.
템플릿을 인스턴스화 하지 않으면 컴파일러는 아무런 코드를 생성하지 않는다.

템플릿 특수화(template specialization)
일부 경우에 대해서 따로 처리하는 것을 템플릿 특수화라고 한다.
ex) template <typename A, typename B, typename C>
class test{};
A int가 C double 일 때 따로 처리하고 싶다면
ex) template <typename B>
class test<int, B, double> {};
위와 같이 A와 C에 원하는 타입을 적용하고 B만 템플릿화 한다.
단 전달하는 템프릿 인자가 없더라도 특수화하고 싶다면 template<> 라도 남겨주어야한다.

함수 템플릿(Function Template)
일반적인 데이터 형 뿐만 아니라 함수 형태의 형태도 템플릿으로 사용 가능하다.
인스턴스화 할때 함수에 사용되는 변수의 데이터 형을 지정해주지 않아도 컴파일러가 알아서 적절한 데이터 형을 선택해서 인스턴스화 해준다.
컴파일 시에 몯느 템플릿을 실제 코드로 변환하여 실행하는데 이러한 방식을 이용해서 템플릿 메타프로그래밍이라하고 9-3에서 자세히 다룬다.

함수 객체(Function Object - Funtor)
함수는 아니지만 함수 인 척을 하는 객체를 함수 객체라 한다.
함수 객체는 클래스 내에서 연산자를 정의하여 해당 객체가 함수처럼 동작하도록한다.
또한 함수 객체는 내부 상태를 가질 수 있어 해당 함수 호출 시 마다 내부 상태를 활용할 수 있다.
Functor의 장점 : 함수 객체는 내부 상태를 가질 수 있어 상태를 기반으로 동작을 수행가능, 템플릿과 결합하여 다양한 타임에 대해 동작할 수 있는 유연한 코드를 작성 가능, C++ 표준 라이브러리의 많은 알고리즘 함수들(sort와 같은)과 호환이 가능

ex)
class Multiply {
public:
    // operator()를 정의하여 Functor로 만듭니다.
    int operator()(int x, int y) const {
        return x * y;
    }
};

int main() {
    Multiply multiply; // Functor 객체 생성
    int result = multiply(3, 4); // Functor를 함수처럼 호출
    std::cout << "3 * 4 = " << result << std::endl; // Output: 3 * 4 = 12

    return 0;
}


타입이 아닌 템플릿 인자(non-type template argument)
템플릿은 인자로 타입말고도 다른 변수도 받을 수 있다.
ex)#include <iostream>

template <typename T, int num>
T add_num(T t) {
  return t + num;
}

int main() {
  int x = 3;
  std::cout << "x : " << add_num<int, 5>(x) << std::endl;
}
위와 같이 변수를 지정할 수 있으나 <>내부에 적절한 값을 집어 넣지 않으면 오류를 발생한다.
템플릿 인자로 타입말고 받을 수있는 형태는 정수형, 포인터 타입, enum 타입, NULL만 가능하다.

디폴트 템플릿 인자
함수에 디폴트 인자를 적용할 수 있듯이 템플릿도 디폴트 인자를 지정할 수 있습니다.
ex) template <typename T, int num = 5>



9-2. 가변 길이 템플릿 (Variadic template)
템플릿은 임의의 개수의 인자를 받을 수 있다.
ex) template <typename T, typename... Types>
void <함수이름>(T arg, Types... args)
typename 뒤에 오는 ...으로 오는 것을 템플릿 파리미터 팩(parameter pack)이라 한다.
함수에 인자로 ...로 오는 것을 함수 파라미터 팩이라 한다.
Types를 기준으로 템플릿 파라미터 팩은 앞에 있고 함수 파라미터 팩은 뒤에 있다.
만약 템플릿 파라미터 팩으로 어떤 함수를 오버로드한다면 파라미터 팩이 없는 함수의 우선순위가 높기때문에 인자가 적은 함수가 호출된다.

Fold Expression
가변 길이 템플릿은 매우 편리하지만 재귀 함수 혐태로 구성해야 하기 때문에, 반드시 재귀 호출 종료를 위한 함수를 따로 만들어야한다.
C++ 17에 새로 도입된 Fold 형식을 사용한다면 간단해진다.
ex)template <typename... Ints>
int sum_all(Ints... nums) {
  return (... + nums);
}

int main() {
  // 1 + 4 + 2 + 3 + 10
  std::cout << sum_all(1, 4, 2, 3, 10) << std::endl;
}
위의 코드를 실행하면 return(... + nums)부분이 return((((1 + 4) + 2) + 3) + 10);처럼 시행됨을 알 수 있다.
(... op <변수>) 오른쪽이나 위와 같은 형태 말고도 (<변수> op ...), (<변수> op ... op <변수>)와 같은 형태로도 사용이 가능하다
단 Fold 연산자를 사용할 때 꼭 ()로로 감싸주어야한다.
