5월 22일 수요일

금일 진행 목표 10장까지



9-3. 템플릿 메타 프로그래밍

템플릿을 통해 타입이 마치 인자 인것 처럼 사용하는 것을 일반화 프로그래밍(generic programming)이라 한다.
같은 템플릿으로 두 개의 클래스를 생성해도 템플릿 인자가 다르면 다른 클래스로 인식 및 생성된다.

템플릿 메타 프로그래밍 (TMP)
여태까지는 어떠한 객체에 무엇을 저장하느냐를 지정하는데 사용해 왔지, 타입 자체가 어떠한값을 가지지는 않았다. 템플릿을 사용시 객체를 생성하지 않더라도 어떠한값을 부여할수 있고 그 타입들을 가지고 연산이 가능하다. 또한 컴파일 타임에 타입은 모두 확정되므로 템플릿의 모든 연산도 컴파일 다임에 끝나게 된다. 이렇게 ㄷ타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍 하는 것을 메타 프로그래밍이라 한다.
일반적인 C++ 코드도 TMP로 변환이 가능하다. 이렇게하면 프로그램 실행 속도를 향상 시킬 수 있으나 위에서 지적하였듯이 컴파일 시에 모든 연산들을 해야하기 때문에  컴파일 시간이 길어지는 문제가 발생한다. 또한 TMP는 매우 복잡하기 때문에 모든 코드를 TMP로 작성하는 것은 어렵고 또한 버그를 찾는 것또한 매우 어렵다. 컴파일 시에 연산하기 때문에 디버깅이 불가능하고 컴파일러 특성 상 템플릿 오류시에 매우 긴 길이의 오류를 생성한다.



9-4. 템플릿 메타 프로그래밍2

템플릿 부분 특수화 시에 반드시 다른 연산자가 붙지 않고 단순한 식별자만 입력해주어야한다.
따라서 struct check_div<N, N/2>와 같은 사용은 불가하다. 대신 직접 계산하는것이 아닌 N/2를 나타내는 타입으로 대체해서 템릿 부분 특수화 문제를 해결할 수있다.(like wrapp)

컴파일러는 구조상 어떠한 식별자를 보았을 때 이 식별자가 값인지 타입인지 결정해야한다.
의존 타입(dependent type)란 템플릿에서 특정 타입이 다른 템플릿 매개변수에 의존 하는 경우를 말한다. 해당 의존 타입을 올바르게 사용하지 않으면 컴파일러가 제대로 해석을 하지 못하여 오류를 발생시킬 수 있다.


*의존 타입에 대한 추가적인 공부 필요*

단위 라이브러리
C++은 여러 수치 계산을 사용하는데에도 많이 사용된다. 특히 수치 계산을 하는 때에  단위가 많이 사용되고 어떠한 변수가 있으면 단독적으로 사용되기 보다는 단위와 함께 붙어서 사용하는 경우가 많다. 컴파일러는 변수형만 같으면 처리하지만 실제 수치 계산에서는 변수형만 같다고 처리하면 (예를 들어 가속도와 속도를 아무런 변환 없이 더해버리면) 실제 계산하면 안되는 것도 계산해버리기에 단위가 붙은 데이터를 처리할 때 항상 단위를 확인해야한다.
위와 같은 문제를 단위 데이터 별로 클래스로 만들어 클래스 객체에 보관하고 단위끼리 체크해서 단위가 맞지 않으면 처리하지 않게하는 법도 있다. 하지만 이는 런타임시에 그냥 넘어가는 문제를 야기할 수 있다. 따라서 단위가 맞지 않는 연산을 수행하는 코드가 있다면 컴파일 시에 오류를 발생시켜서 아에 틀린 단위 연산을 막고 프로그램을 실행하며 오류를 찾아가지 않아도 된다.

알아서 타입을 추측하는 auto
컴파일러가 타입을 정확히 알아낼 수 있는 경우 굳이 긴 타입을 적지않고 auto로 표현가능하다.
템플릿 사용으로 복잡해진 타입 이름들을 간단하게 나타낼수 있는 획기적인 방법(?? 변수 타입이면 금방 auto가 무엇을 가르키는지 알 수 있지만 함수 포인터나 구조체면??)



10-1. C++ STL - 벡터(std::vector), 리스트(list), 데크(deque)

C++ 표준 템플릿 라이브러리 STL(Standard Template Library) - vector<>와 같이 <>안에 원하는 자료형을 넣어 원하는 자료형을 저장하는 배열을 쉽게 만들수 있다
STL은 임의 타입의 객체를 보관할 수 있는 컨테이너, 컨테이너에 보관된 원소에 접근할 수 있는 반복자, 반복자들을 가지고 일련의 작업을 수행하는 알고리즘
또한 다루려는 객체가 어떤 특성을 갖는지 무관하게 템플릿을 적용한 라이브러리를 자유롭게 사용가능, 임의의 클래스의 객체여도 위의 라이브러리가 제공하는 기능을 사용할 수 있다. M개 종류의 컨테이너에 대해 N개 종류의 알고리즘을 적용할려면 NM개의 알고리즘 코드가 있어야하나 반복자의 도입으로 N개의 알고리즘 코드만 있어도 모두 기능한다.

C++ STL 컨테이너 - std::vector
배열처럼 객체들을 순차적으로 보관하는 시퀀스 컨테이너(sequence container) - vector, list, deque
키를 기반으로 대응되는 값을 찾아주는연관 컨테이너(associative container)

어떠한 작업의 처리 속도를 복잡도라고 하고 Big O 표현법에서는 최고차항만을 표현한다

반복자(iterator)
반복자는 컨테이너 원소에 접근할 수 있는 포인터와 같은 객체.알고리즘 라이브러리 대부분은 이 반복자를 이용해서 컨테이너에 접근한다.
*와 iterator는 어디에 접근하는 동일한 기능은 담당한다.

vector의 경우 임의의 위치에 바로 접근(O(1))할 수 있다. 대신 원소를 삭제하거나 삽입할 때 최악의 경우 모든 원소들을 복사할 필요가 있어 O(n)의 복잡도를 갖는다.
vector에서 다양한 반복자들이 있는데 맨 앞 원소를 가르키는 begin(), 맨 마지막 원소의 *뒤*를 가르키는 end(), 접근만하고 값을 변경할 수 없는 cbegin(), cend(), 역반복자인 맨 뒤의 원소를 가르키는 rbegin(), 맨 앞쪽 원소의 *앞*을 가르키는 rend() 등이 존재한다.
vector의 컨테이너에 접근할 때 컨테이너의 원소 중 가장 뒷 원소에서부터 앞으로 접근하면 가장 앞의 원소에 접근후 더 앞의 부분에 접근할 수 있고 이렇게 되면 오류가 발생한다. 이를 방지하기위해 역반복자를 사용하면 더 앞부분을 만나더라도 rend()이기 때문에 오류가 발생하지 않는다.

범위 기반 for문 (range based for loop)
범위 기반 for문은 직관적으로 시퀀스 컨테이너를 순회할 수 있고 코드의 가독성을 높이며 STL와 높은 호환성을 가진다.

list의 경우 양방향 연결 구조를 가진 자료형이라 볼수 있다. 따라서 벡터와 달리 임의의 위치에 있는 원소에 바로 접근하는 것이 불가능하다.
list 컨테이너는 시작 원소와 마지막 원소의 위치만 기억하고 있기 때문에 임의의 위치 원소에 접근할려면 하나하나 링크를 따라가야한다.O(n)
하지만 원소를 삭제하거나 집어 넣을 경우 링크만 새로 설정해주면 되어 O(1)의 시간이 소요된다. list 특성상 하나의 원소는 자신의 오른쪽과 왼쪽에 붙어 있는 원소를 알고 있고 이렇기에 삭제가 시행되어도 원소 자체가 삭제되는 것이 아닌 링크만 끈어내는 방식으로 진행이 하기에 반복자가 무효화 되지 않는다.

deque은 vector와 유사하게 임의의 위치에 접근하는데 O(1)만큼 소요되고 맨 뒤에 원소를 추가 제거하는데 걸리는 시간이 O(1)이나 임의의 위치의 원소를 추가 제거하는데는 O(n)의 시간이 소요되나 속도는 vector보단 빠르다. 삭제나 삽입은 빠르지만 deque은 하나의 원소를 보관하는데 그 원소 크기에 8배에 해당하는 더 많은 메모리르 필요하는 속도는 빠르나 메모리를 많이 소모하는 컨테이너라 보면된다. deque의 원소들이 일정 크기로 잘려서 각각의 블록 속에 존재한다. 해당 블록 들은 메모리 상 어느 곳에 위치하여 있는지 저장하기 위해 각각의 블록들의 주소를 저장하는 벡터가 필요로한다. 이 블록 내부에 순서대로 원소들이 나열하여 저장된다.만약 새로운 원소를 삽입하면 vector의 경우 메모리 공간을 새로 할당해야하는 것과 달리 deque는 블록들이 가지고 있는 vector들의 적절히 빈 공간에 집어 넣으면 된다.

컨테이너를 사용할 때 대부분의 경우 vector를 사용하면 되지만 중간에 원소들을 많이 추가하거나 제거할 경우 list를 사용하고 맨처음과 끝에 추가하거나 제거할 일이 많으면 deque를 사용한다.



10-2. C++ STL - 셋(set), 맵(map), unordered_set, unordered_map

연관 컨테이너는 특정 key 값을 넣으면 이에 대응하는 value를 돌려주는 key-value 구조를 가진다.
연관 컨테이너의 대략적인 구성은 특정 키가 연관 컨테이너에 존재하는지 유무를 파악하는 set, multiset과 만약 이에 대응되는 값이 무엇인지 질의하는 map, multimap을 제공한다. map, multimap은 대응 되는 값을 가져올 수 있는지 없는지를 통해 set, multiset을 파악할 수 있다. 하지만 map의 경우 set보다 사용하는 메모리의 양이 훨씬 많기 때문에 key의 존재 유무만 확인할 필요가 있다면 set을 사용하는 것이 좋다. 원소를 추가할 때 시퀀스 컨테이너처럼 어디에 추가할지에 대한 정보가 없고 메모리 어디엔가에 key값과 value값을 저장한다.

set에 있는 원소에 접근할 때 양방향 접근자를 이용해 순차적으로 하나하나 탐색하며 접근해야한다. set의 경우 원소를 추가할 때 정렬된 상태로 추가한다. set 내부의 원소를 탐색할 때 이미 sort된 곳을 탐색하기 때문에 탐색 시간은 시퀀스 컨테이너의 최악의 경우인 O(n)과 다르게 O(log n)이 소요된다.
set의 노드들 정렬할 때 자신 보다 작은 노드는 왼쪽, 큰 노드는 오른쪽에 두는 형태로 미리 binary tree를 구성하면 n개의 노드를 정렬할 때 정확히 (log n)/(log 2)의 깊이를 갖게된다. 따라서 가장 아래 쪽의 노드를 탐색해도 (log n)/(log 2)번 탐색만 하면된다. 또한 내부에 동일한 값을 넣어도 insert하지 않는다. 왜냐하면  set 구조는 하나의 key 값에 하나의 value를 갖는 것이 원칙이기 때문이다.
클래스 객체를 set의 원소로 사용할때 (Set 내부의 원소들을 정렬하기 위한 비교 연산을 할 수 있을 것 -> operator<을 정의하기)과 (비교 연산은 < 과 같이 동일한 key에 대한 처리를 지원하지 않기에 동일한 key를 처리해야 한다)을 주의해야한다.

map의 경우 set에서 각 노드 key값에 대응하는 value도 같이 저장하는 형태이다.
std::map<std::string, double> map_name; 옆에서 <>안에서 앞에 존재하는 것이 key 값이고 뒤에 존재하는 것이 value 값이다.
map에는 std::pair<std::string, double>("string", number), std::make_pair("string", number), map["string"] = number 등과 같이 다양한 방법을 통해 key,value값을 추가할 수 있다. 기존에 이미 key가 할당되어 있다면 해당 key의 value 값의 새로 입력한 값으로 바뀐다. 만약 맵에서 존재하지 않는 key값의 value을 받을려하면 오류가 발생한다. 대신 map["string"]으로 접근하면 자동으로 디폴트 생성자를 호출하여 해당 key값의 value값을 자동으로 초기화하기 때문에 접근은 가능하나 value값은 초기값만 얻을 수 있다. 따라서 불필요한 생성이나 오류를 막기 위해 해당 key에 접근할 때 find를 이용하여 접근하는 것이 좋다.

정렬되지 않은 set과 map
말그대로 정렬하지 않은 set과 map이다. 실제 출력을 해보면 순서대로 출력되는 것이 아니라 아무값이나 출력하게된다. 이 둘은 삽입, 삭제, 탐색 모두 O(1)에 가능하다.
새로운 원소가 삽입되면 임의의 크기 데이터를 고정된 크기의 데이터로 대응 시켜주는 해시 함수를 사용해 해수 함수는 1부터 상자의 수까지의 값을 최대한 고르게 반환하고 그 해시값을 원소를 저장하는 번호로 삼게된다. 이 해쉬 값을 이용해 원소에 접근하기 때문에 시퀀스 컨테이너에 접근하는 것 처럼 탐색에 O(1)의 시간이 소요된다. 가능한한 다른 원소는 다른 해시 값을 갖는게 원칙이지만 다른 원소임에도 같은 해시 값을 갖는 경우가 있는데 이를 해시 충돌이라한다. 이와 같이 매우 운이 없는 경우에 여러개의 원소가 모두 동일한 해쉬 값을 가질 수도 있고 이렇게 되면 탐색 시간은 O(n)이 된다. 그렇기에 일반적으론 정렬되지 않은 set과 map은 해쉬 함수를 매우 잘 설계해서 최적화가 매우 필요한 곳에만 사용하고 일반적으론 그냥 set이나 map을 사용한다.

전제적으로 데이터의 존재 유무만 필요할 경우 set, 중복 데이터도 꼭 허락해야할 경우 multiset, 데이터에 대응되는 데이터를 저장하고 싶으면 map, 중복키를 허락할 경우 multimap, 속도가 매우 중요할 경우 unordered_set 또는 unordered_map을 사용하면된다



10-3. C++ STL - 알고리즘(algorithm)

알고리즘 라이브러리는 컨테이너 반복자들의 정렬, 검색, 삭제, 삽입, 다양한 조건의 작업 등의 수행을 수월하거나 더욱 빠르게 수행할 수 있도록 도와주는 라이브러리다.
template<typename T>
void function(T begin, T end)

template<typename T, typename P>
void function(T begin, T end, P pred)
위와 같이 시작과 끝을 넣고 특정 조건을 갖는 pred을 이용해 알고리즘 라이브러리를 사용한다.

정렬은 여러가지가 있는데 sort는 일반적인 정렬함수, stable_sort는 크기가 같다면 그 순서를 보존하는 sort, 배열의 일부분만 정렬하는 partial_sort가 있다.
**단 정렬의 경우 반시드 임의 접근 반복자 타입을 만족하는 vector나 deque 같은 형태만 가능하고 나머지는 사용할 수 없다.**
정렬 알고리즘의 3번째 특정 조건 인자는 다양한 조건을 받을 수 있다. 기본적으로 조건이 없으면 오름차순으로 정렬하나 새로운 조건 함수 
template <typename T>
struct greater_comp {
  bool operator()(const T& a, const T& b) const { return a > b; }
};
와 같은 조건 함수를 3번째 인자로써 사용하면 내림차순으로 정렬이 가능할 뿐아니라 다양한 자료형도 typename을 이용해 사용가능하다.

원소 제거
컨테이너는 기본적인 제거 함수를 지원하지만 특정 조건을 만족하는 원소를 제거하는 함수는 알고리즘 라이브러리으 remove, remove_if를 사용하여 제거한다.
**remove 함수는 기본적으로 컨테이너 내부의 원소들을 이동시키기만하고 뒤로 밀어버리는 작업만 한다. 실제 원소들을 제거하기 위해 별도의 erase 함수를 호출하여 원소를 지워주워야한다.**
특정 조건을 만족하는 원소들을 제거할 때는 remove_if 함수를 사용하면 된다. remove_if는 함수 객체가 인자를 딱 1개만 받는다고 가정한다.

람다 함수
람다 함수는 이름 없는 함수를 쉽게 만들수 있게 도와준다.(리턴_타입은 생략 할 수도 있다.)
ex) [](받는 인자) -> 리턴_타입 { 함수 본체 }

람다 함수로 이미 생성된 함수 객체도 호출할 수 있다.
ex) auto is_odd = [](int i) { return i%2 == 1}

기본적으로 함수는 외부에서 정의된 변수들을 사용할 수없지만 람다함수는 [] 내부를 이용해서 접근하는 것이 가능하다

원소를 탐색하는 함수
*find 계열의 함수들을 사용할 때 한 가지 주의해야 할 점은 컨테이너에서 기본적으로 제공하는 find 함수가 있다면 해당 함수가 더 빠르다.*'
set의 경우 set이 지원하는 find 함수는 O(log n)의 시간이 소요되지만 알고리즘 라이브러리에서 지원하는 fing 함수를 사용하면 우직하게 맨 처음부터 탐색하므로 O(n)의 시간이 소요됩니다.
