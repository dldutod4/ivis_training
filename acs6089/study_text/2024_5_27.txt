5월 27일 월요일

16-3까지 목표로 진행하겠습니다.

15-4. C++ future, promise, packaged_task, async

한 번에 하나씩 순차적으로 실행되는 작업을 동기적으로 실행 된다 라고 한다. 동기적인 작업들은 한 작업이 끝날 때 까지 다음 작업으로 이동하지 않는다. 느린 second storage에서 무엇인 가를 읽어 올 때 다 읽어 올 때까지 기다린다면 매우 비효율적이다. 따라서 그 시간 동안 따른 작업을 하는 것이 좋다. 따라서 프로그램이 한 갈래가 아니라 여러 갈래로 갈라져서 동시에 진행되는 것을 비동기적 실행이라고 한다.

promise, future
비동기적 실행으로 하고 싶은 일은 어떠한 데이터를 다른 쓰레드를 통해 처리해서 받아내는 것이다. 따라서 어떤 쓰레드 T를 사용해서 비동기적으로 값을 받아 내겠다 라는 의미는 미래에 (future) 쓰레드 T가 원하는 데이터를 돌려 주겠다 라는 약속(promise)라고 볼 수 있습니다.

promise 객체는 정의할 때 연산을수행 후 돌려줄 객체의 타입을 템플릿 인자로 받는다. 연산이 끝나면 promise 객체는 자신이 가지고 있는 future 객체에 값을 넣어 준다. 이때 promise에 대응되는 객체는 get_future 함수를 통해 연결을 한다. future 객체는 get 함수를 통해서 promise가 전달하는 정보를 기다렸다가 promise가 정보를 전달할 때 자동으로 sleep 상태에 있던 future 객체가 깨어나 후속 작업을 진행한다. 위의 과정에서 보듯이 promise 객체는 마치 생산자처럼 작동하고 future는 소비자 처럼 작동한다.

만약 promise가 너무 늦게 수행된다면 future 객체가 wait_for 함수를 이용해서 일정시간만 기다리다가 일정시간이 지나면 뒤의 작업을 그냥 수행하게할 수 있다. wait_for 함수는 전달된 시간 만큼 기다렸다가 바로 future 객체의 상태를 나타내는 future_status 값을 리턴하는데 이 futrue_status는 future에 값이 설정 됐을 때 future_status::ready를 리턴하고, wait_for가 지정한 시간을 지나면 future_status::timeout을 리턴하고, 결과값을 계산하는 함수가 다 실행되지 않으면 futrue_status::deferred를 리턴한다.

여러개의 다른 쓰레드에서 future를 get할 필요가 있을 때는 shared_future를 사용하면 된다. shared_future는 futrue와 다르게 복사가 가능하고, 복사본들이 모두 같은 객체를 공유하기 때문에 레퍼런스나 포인터로 전달할 필요가 없다.

packaged_task
위의 promise-future 패턴을 비동기적 함수(Callable, 람다함수, Functor)의 리턴값에 간단히 적용할 수 잇는 packaged_task를 지원한다.

packaged_task 는 비동기적으로 수행할 함수 자체를 생성인자로 받는다.
템플릿 인자로 해당 함수의 타입을 명시해야 한다.
ex)std::packaged_task<int(int)> task(some_task);

해당 promise에 대응되는 futrue는 아래와 같이 get_future 함수로 얻는다.
ex) std::future<int> start = task.get_future();

생성된 packaged_task를 아래와 같이 쓰레드에 전달한다
ex) thread t(std::move(task), 5);


async
async 함수는 인자로 받은 함수를 비동기적으로 실행한 후에, 해당 결과값을 보관할 future를 리턴한다.
std::launch::async  바로 쓰레드를 생성해서 인자로 전달된 함수를 실행한다.
std::launch::deferred  future의 get 함수가 호출되었을 때 실행한다(새로운 쓰레드는 생성하지 않는다)
바로 당장 비동기적으로 실행할 필요가 없다면 동기적으로 실행하는 launch::deferred를 사용하면 된다.




15-5. C++ 쓰레드풀(ThreadPool) 만들기

쓰레드풀이란 여러 개의 쓰레드들이 대기하고 있다가, 할 일이 들어오게 되면 대기하고 있던 쓰레드들 중 하나가 이를 받아서 실행하게 해주는 일 종의 풀이다.
쓰레드풀은 여러 쓰레드들을 받아서 처리해야하기 때문에 쓰레드들을 보관할 컨테이너가 많이 필요하다. 또한 이 보관한 쓰레드들을 FIFO 방식으로 처리할려면 위해 큐 구조의 컨테이너를 사용하면 좋다. 쓰레드풀은 다양한 형태의 일반적인 함수들을 처리해야하기에 일반적인 함수들을 보관할 수 있는 컨테이너를 필요로한다.

쓰레드풀에서 다양한 함수들을 처리할고 보관할 수 있는 큐 컨테이너는 아래와 같은 순서로 설계할 수 있다.
1. std::queue<std::function<void()>> jobs_;
위의 큐는 가장 오래 전에 추가된 작업을 쉽게 알아 낼 수 있다.

2.std::condition_variable cv_job_q_;
std::mutex m_job_q_;
queue는 공유 자원을 안전하게 보호하는 장치가 없다. 따라서 위와 같이 현재 사용 중인 자원을 관리해줄 condition_variable과 mutex가 필요하다.

3. template <class F, class... Args>
std::future<typename std::result_of<F(Args...)>::type> EnqueueJob(F f, Args... args);
전달한 함수가 여러 인자들을 받아 결과 값을 리턴할 때 위와 같은 구조로 만들면된다.

4. using return_type = typename std::result_of<F(Args...)>::type;
  std::packaged_task<return_type()> job(std::bind(f, args...));

  std::future<return_type> job_result_future = job.get_future();
  {
    std::lock_guard<std::mutex> lock(m_job_q_);
    jobs_.push([&job]() { job(); });
  }
비동기적으로 실행되는 함수의 리턴값을 받아내는 구조는 위와 같이 구현하면된다.

5.auto job = std::make_shared<std::packaged_task<return_type()>>(std::bind(f, args...));
std::future<return_type> job_result_future = job->get_future();
{
  std::lock_guard<std::mutex> lock(m_job_q_);
  jobs_.push([job]() { (*job)(); });
}
컨테이너 내부의 처리할 함수 객체 job 지역함수 이기에 컨테이너 함수 EnqueueJob이 리턴하면  파괴되어 람다함수 [&job]() { job(); }가 접근할 때는 이미 job이 파괴되어 있다. 이를 해결하기 위해 packaged_task를 더 이상 사용하지 않아도 함부로 파괴하지 않게하기 위해 shared_ptr을 사용하여 job 객체가 함부로 파괴되는 것을 위와 같은 방법으로 막는다.

6. template <class F, class... Args>
std::future<typename std::result_of<F(Args...)>::type> EnqueueJob(F&& f, Args&&... args);
auto job = std::make_shared<std::packaged_task<return_type()>>(std::bind(std::forward<F>(f), std::forward<Args>(args)...));
ThreadPool::EnqueueJob(F f, Args... args)는 인자들의 복사본을 받는다. 이 복사본을 받기보단 완벽한 전달을 통해 불필요한 복사를 위와 같은 방법으로 줄이면 좋다.




16-1. C++ 유니폼 초기화(Uniform Initialization)

C++ 컴파일러는 함수의 정의처럼 보이는 것들은 모두 함수의 정의로 해석하기에 생성자를 사용할 때 주의해야한다.
연산자 ()는 함수의 인자들을 정의하는데도 사용되고 그냥 일반적인 객체의 생성자의 호출에도 상용되기 때문에 생성자를 호출하고 싶으면 균일한 초기화가 사용하는 연산자 {}를 사용하면된다. 단 연산자 {}를 이용한 균일한 생성자는 암시적 타입 변환들을 불허하는 데이터 손실이 있는 변환을 한다.
연산자 {} 사용하여 생성자를 호출할 때 initializer_list는 클래스 생성자들 중에 initializer_list를 인자로 받는 생성자가 있다면 전달된다. 
initializer_list를 받는 생성자 중에 {}를 이용해서 객체를 생성할 경우 생성자 오버로딩 시에 해당 함수에서 해당 생성자와 매칭시키려고 최선을 다해 노력한다. auto를 사용하여 auto x = {arg1, arg2...}의 형태를 구성하면 arg1, arg2 ...이 모두 같은 타입 T라면 initializer_list<T>로 추론된다.
auto x {arg1, arg2 ...} 형태의 경우 만일 인자가 단 1개라면 인자의 타입으로 추론되고 여러개 이면 오류를 발생시킨다.




16-2. constexpr 와 함께라면 컴파일 타임 상수는 문제없어

해당 객체나 함수의 리턴값을 컴파일 타임에 값을 알 수 있다라는 함수 앞에 붙일 수 있는 키워드로 constexpr 키워드가 있다. 컴파일러가 컴파일 타임에 어떠한 식의 값을 결정할 수 있다면 해당식을 상수식이라고 한다. 따라서 constexpr는 어떠한 식이 상수식이라고 명시해주는 키워드이다. constexpr와 const는 언듯 비슷해 보이지만 constexpr는 반드시 오른 쪽에 상수식이 와야하고 const로 정의된 상수들은 굳이 컴파일 타임에 그 값을 알 필요가 없다. 따라서 모든 constexpr는 항상 const 이지만 모든 const는 항상 constexpr이 아니다. 따라서 컴파일 타임에 상수를 확실히 사용하고 싶다면 constexpr 키워드를 꼭 사용해야한다. #define은 타입의 안전성을 제공하지 않고 전역적이여서 파일 전체에 유효하며 디버깅 시 치환된 값만 보이고 반면 constexpr은 명시적으로 해당 변수가 어떤 타입인지 제안하고 일반적인 변수의 범위 규칙을 따르며 디버깅 시에도 이름과 타입 정보를 유지한다. 특히 TMP의 형태로 수행하는 코드를 작성하면 이해하기 어렵게 작성될 가능성이 높다. 반면 리턴 타입에 constexpr을 추가한다면 조건이 맞을 때, 해당 함수의 리턴값을 컴파일 타임 상수로 만들 수 있다. constexpr은 goto문, 예외처리, 리터럴 타입(컴파일러가 컴파일 타임에 정의할 수 있는 타입)이 아닌 변수의 정의, 초기화 되지 않는 변수의 정의, 실행 중간에 constexpr이 아닌 함수를 호출하는 경우만 아니면 사용이 가능하다. constexpr 함수는 컴파일 타임 상수들 말고 다른 상수도 인자로 받을 수 있다. *대신 컴파일 타임 상수 이외 값을 인자로 받으면 일반 함수처럼 사용된다.*

리터럴 타입이란 컴파일러가 컴파일 타임에 정의할 수 있는 타입의 변수들이다. 리터럴 타입에는 void, 스칼라 타입(char, int, bool,float등등), 레퍼런스 타입, 리터럴 타입의 배열, 디폴트 소멸자를 가지고 람다 함수, Arggregate 타입(pair 같은 타입), constexpr 생성자를 가지며 복사 및 이동 생성자가 없는 타입들이 있다.

constexpr 생성자
constexpr 로 생성자를 선언하면 위와 같은 일반적인 constexpr 함수에 적용되는 제약조건들이 모두 적용된다. 따라서 constexpr 생성자의 인자들은 반드시 리터럴 타입이여만 하고 해당 클래스는 다른 클래스를 가상 상속 받을 수 없습니다. * constexpr 객체의 constexpr 맴버 함수만이 constexpr을 줄 수 있다. 만약 하나라도 constexpr이 아니면 컴파일이 되지않는다. *
타입에 따라 형태가 달라지는 함수라면 인자가 포인터 타입이면 *한것을 리턴하고 아니면 원래 인자를 리턴하는 get_value 함수와 템플릿 타입 유추를 써서 구현할 수 있다. 또는 <type_traits>에서 여러가지 템플릿 함수들을 제공하는데 이들 중 is_pointer는 타입이 포인터 인지 아닌지 확인하는 함수도 있기에 해당 함수를 써서 구현하여도 된다. 포인터르 인자를 갖는 함수와 아닌 함수 각각을 만들어 오버로드 해도 되지만 조건으로 반드시 bool로 탑 변환될 수 있어야하는 컴파일 타임 상수식을 받는 if constexpr을 쓰면 해당 조건이 참이라면 else에 해당하는 부분은 완전히 무시하여 컴파일 하지 않아 하나의 함수 내에서 구현이 가능하다.




16-3. 타입을 알려주는 키워드 decltype 와 친구 std::declval

decltype 는 함수와는 달리 타입을 알고자 하는 식의 타입으로 치환되게 된다. 단  decltype에 전달된 식이 괄호로 둘러쌓이지 않은 식별자 표현식이어야지 해당 식의 타입을 얻을 수 있다. 식별자 표현식이란 어떠한 연산을 하지 않고 단순히 객체 하나만을 가리키는 식이다. 만약 decltype에 식별자 표현식이 아닌 식을 전달하면 xvalue이면 T&&를 lvalue라면 T&를 prvalue라면 T를 반환 한다. decltype은 auto와 비슷하만 auto는 정확한 타입을 표현하지 않는 대신 decltype은 정확한 타입을 반환한다. 배열의 경우 auto는 암시적으로 포인터를 변환하지만 decltype은 배열 타입을 그대로 전달한다.

Value Category
C++의 모든 식에는 타입과 값 카테고리 2가지가 항상 따라다닌다. 정체를 알 수 있는 모든 식은 gvalue, 이동 시킬 수 있는 모든 식은 rvalue, 세부적으로 이동 시킬수 있으며 정체를 알 수 있으면 xvalue, 이동 시킬 수 있으며 정체를 알 수 없으면 prvalue, 이동 시킬 수 없으며 정체를 알 수 있을 때 lvalue로 분류 된다.

lvalue
int i와 같이 실제 변수가 존재하며 정체를 알 수 있으니 int&& x = i와 같이 이동 시킬 수 없는 lvalue이다. 이름을 가진 대부분의 객체들은 모두 lvalue이다. 왜냐하면 해당 객체의 주소값을 취할 수 있기 때문이다. lvalue는 변수, 함수의 이름, 어떤 타입의 데이터 맴버(std::cin, std::endl) 등등, 좌측값 레퍼런스를 리턴하는 함수의 호출식(std::cout << 1), 복합 대입 연산자 식(a += b;), 전위 증감 연산자 식(++a), 배열 참조 식(a[n]), 문자열 리터럴("hi"), 맴버를 참조하는 것(a.m, a->m) 중 m이 enum이너가  static이 아닌 맴버 함수인 경우 제외 들이 있다. 특히 lvalue들은 연산자 &를 통해서 주소값을 알아 낼 수 있다. 

prvalue
정체를 알 수 없는 즉 메모리 주소에 접근할 수 없고 좌측에 올 수 없는 값들을 prvalue라고 한다. prvalue에는 문자열 리터럴을 제외한 모든 리터럴(42, true 등등), 레퍼런스가 아닌 것을 리턴하는 함수의 호출식(str1 + str2), 후위 증감 연산자 식(a++), 디폴트 산술 논리 연산자 식(a+b, a<b), 주소값 연산자 식(&a), 맴버를 참조할 때(a.m, a->m) m은 enum 이거나 static이 아닌 맴버 함수, this, enum, 람다식 ( [](){return 0;};)

xvalue
좌측값 처럼 정체가 있지만 이동도 시킬 수 잇는 것들, 대표적으로 우측값 레퍼런스를 리턴하는 함수의 호출식을 들 수 있다. ex) std::move(x)
move를 호출한 식은 lvalue 처럼 좌측값 레퍼런스를 초기화 하는데 사용할 수도 있고, prvalue 처럼 우측값 레퍼런스에 붙이거나 이동 생성자에 전달해서 이동 시킬 수 있다.


declval
declval은 decltype과 다르게 키워드가 아닌 <utilty>에 정의된 함수이다. 또한 decltype 안에 들어가는 식은 형태로만 존재할 뿐 컴파일 시에 decltype() 전체 식이 타입으로 바로 변환 되기 때문에 decltype 안에 있는 식은 런타임 시에 실행되는 것이 아니다. 
template <typename T>
decltype(T().f()) call_f_and_return(T& t) {return t.f();}
struct A {
  int f() { return 0; }
};
struct B {
  B(int x) {}
  int f() { return 0; }
};
위와 같은 상황에서 두 구조체의 생성자가 다름을 볼 수 있다. 여기서 B구조체는 생성자 T()를 갖고 있지 않다. 여기서 decltype을 사용하면 없는 생성자를 사용할려 했기 때문에 오류가 발생한다.

decltype(std::declval<T>().f()) call_f_and_return(T& t) {return t.f();}
대신 2번째 줄을 위와 같이 바꾸게 된다면 declval이 T의 생성자를 직접 호출하지 않더라도 T가 생성된 객체를 나타낼 수 있다. 단 declval 함수를 타입 연산에서만 사용해야한다.
