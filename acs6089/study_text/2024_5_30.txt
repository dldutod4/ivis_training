5월 30일 목요일

금일은 22장까지 진행하겠습니다.

20-3. 코드 부터 실행 파일 까지 - 링킹 (Linking)

심볼들의 위치들을 정할 때 어떠한 방식으로 정할지 알려주는 키워드들이 있는데 이들을 바로 저장 방식 지정자라고 한다.
C++에서 허용한느 저장 방식 지정자는 static, thread_local, extern, mutable 4가지가 있다. C++11, 17이전에는 auto, register등도 있었지만 더 이상 지원하지 않고 나머지 지정자들은 저장 기간과 링크 방식이라는 중요한 정보를 지정할 수 있다.
저장 기간은 지역 변수 같이 {} 안에 정의된 객체들로 코드 블록을 빠져나가게 되면 자동으로 소멸하는 자동 저장 기간, statc 같이 프로그램이 시작할 때 할당하고 끝날 때 소멸되는 static 저장 기간, 쓰레드가 시작할 때 할당되고 쓰레드가 종료될 때 소멸되는 쓰레드 저장 기간, 동적 함수를 통해서 동적으로 할당되고 해제되는 객체들이 가지는 동적 저장 기간 등 으로 세분화 되어있다.

링크 방식
저장 방식은 객체들에게만 해당되는 내용이지만 링크 방식의 경우 모든 객체, 함수, 클래스, 템플릿, 이름 공간 등등을 지칭하는 이름들에 적용된다.
블록 스코프 안에 정의되어 있는 이름들의 경우 링크 방식 없음에 해당된다. 링크 방식이 지정되지 않은 객체들의 경우에는 같은 스코프 안에서만 참조할 수 있다. 내부 링크 방식으로 정의된 것들의 경우 같은 해석 유닛 안에서만 참조할 수 있고  static 키워드로 정의된 함수, 변수, 템플릿 함수, 템플릿 변수들이 이에 해당한다. 외부 링크 방식으로 정의된 객체들은 다른 해석 유닛에서도 참조 가능하다. 거기에 더해 외부 링크방식으로 정의된 객체들은 언어 링크 방식을 정의할 수 있어서 다른 언어 사이에 함수를 공유하는 것이 가능하다.

이름 맹그링
C++에서 C함수를 사용 사용하기 위해서는 C의 컴파일러가 함수 이름을 변환하는 방식과 C++의 컴파일러가 함수이름을 변환하는 방식이 다르기 때문에 extern "C"로 언어 링크 방식을 명시해주어야 한다. C의 경우 함수 이름 변환 자체가 이루어지지 않는다. 반면 C++의 경우 함수의 이름을 바꾸는 이를 이름 맹글링이라 한다. 따라서 C++의 경우 같은 이름에 받은 인자들을 받아도 다른 이름 공간에 들어가면 다른 함수로 취급된다. 또한 이름 맹글링을 하게되면 원래 함수 이름 공간 정보와 함수 인자 타입 정보들이 추가된다. 만약 C에서 C++의 함수를 호출하고 싶다면 반드시 이름 맹글링이 되지 않은 함수 심볼을 생성해야하고 이를 위해서 extern "C"를 통해서 해당 함수는 이름 맹글링 하지 않도록 명시하고 컴파일러에게 전달해야한다.

링킹
위의 단계들을 모두 거치고 각 단계에서 목적하는 것을 아무런 문제 없이 진행되었다면 각각의 해석 유닛들에서 생성된 목적 코드들을 한데 모으는 하나의 실행 파일을 만드는 링킹 작업을 수행할 수 있습니다. 링킹 작업 전까지는 각 변수들과 함수, 데이터들의 위치를 확정 지을 수 없다. 각 해석 유닛들은 생성한 목적 코드들에게 각각의 심볼들의 저장 방식과 링크 방식에 따라 어떻게 어디에 배치했으면 좋겠다라는 희망 사항만 써있다. 해석 유닛 object 파일을 살펴보면 대문자 알파벳의 경우 해당 심볼은 외부 링크 방식으로 선언된 심볼이란 의미이고 다른 해석 유닛에서 전근할 수 있는 심볼이다. 반면 소문자 알파벳의 경우 해당 심볼은 해당 해석 유닛 내부에서만 접근이 가능한 내부 링크 방식으로 선언된 심볼이다.

재배치
해석 유닛에서 생성된 object 코드들은 링킹 과정 전까지 심볼들의 위치를 확정할 수 없기 때문에 확저이 되면 값을 바꿔야할 부분들을 적어둔 재배치 테이블을 생성한다. 내외부 링크 방식인 변수들은 데이터 섹션과 초기화 되지 않은 데이터 섹션이 확정되기 전까지 해당 변수들은 추후에 배치해야한다. 

링크 방식(정적 링킹, 동적 링킹)
정적 라이브러리
라이브러리란 프로그램이 동작하기 위해 필요한 외부 목적 코드들이다. 정적 라이브러리는 우리가 필요로하는 라이브러리가 링킹 후에 완성된 프로그램 안에 포함된다. 다시 말해 실행 파일 자체에 해당 라이브러리 코드가 들어가 있는 형태이기에 정적이라고 한다. 어떤 라이브러리의 소스 코드가 있다면 해당 코드들을 컴파일하면 object 코드가 생성된다. 이렇게 생성된 object 코드들을 묶어 주면 정적 라이브러리 파일이 생성된다. 통상적으로 정적 라이브러리 파일은 .a 확장자를 가진다. 만약 메인 프로그램에서 앞의 라이브러리를 사용할 때 .a 확장자로된 정적 라이브러리 파일이 있으면 다시 컴파일할 필요없이 바로 가져다가 링킹에 쓸 수 있다. 이처럼 정적 라이브러리 파일은 링크 타임에 바인된다.

공유 라이브러리
정적 라이브러리는 이미 프로그램 내부에 필요한 코드들이 모두 있기 때문에 환경에 크게 상관없이 프로그램을 실행 시킬 수 있다. 하지만 모든 라이브러리를 내장 시킬 시 프로그램의 크기가 매우 커지고 메모리에 로드할 때도 같이 올라가기 때문에 메모리를 많이 사용하게 되고 라이브러리가 업데이트 되었을 때 해당 라이브러리를 적용시킬려면 프로그램을 새로 빌드해야하는 문제가 발생한다. 모든 프로그램들이 같은 라이브러리를 링킹 하더라도 정적으로 링킬할 경우 모든 프로그램 내에 동일한 라이브러리 코드를 각자 포함하는 문제 또한 발생한다. 이렇게 다양한 프로그램들이 사용하는 라이브러리를 각각의 프로그램들에 내장하는 것보단 라이브러리를 컴퓨터 메모리에 올려놓고 이를 사용하는 프로그램들이 해당 라이브러리를 공유하는 방법이 공유 라이브러리의 출발이다. 여기서 프로그램들은 각자의 가상 메모리 영역을 가지는데 공유 라이브러리가 있는 위치에 각각의 프로그램이 접근하기 위해서 각자의 가상 메모리에서 공유 라이브러리를 가르키는 주소를 실제 물리 메모리로 변환하는 페이지 테이블에서 실제 공유 라이브러리가 있는 물리 메모리 주소를 전달해주면 공유할 수 있게된다.
공유 라이브러리의 경우 실제 어디에 위치해 있는지 모르기 때문에 사용할 함수를 직접 호출하는 것은 불가능하고 GOT(Global Offset Table)이라는 데이터 테이블을 프로그램 내부에 만든 다음 실제 함수들의 주소값을 적어 놓고 함수를 호출할 떄 해당 함수의 실제 위치를 GOT를 보고 알아낸다.




20-4. 코드 부터 실행 파일 까지 - main 으로의 여정

소스 코드를 빌드하게되면 해당 소스 코드를 실행하기 위한 많은 기반들이 필요하고 따라서 간단한 소스 코드를 빌드해도 크기가 큰 실행파일이 생성된다. 따라서 사용되는 기반들이 모두 호출되고 난 다음에 작성한 소스 코드 부분에 해당하는 부분을 호출한다. 프로그램이 시작하면 _start 함수가 가장 먼저 호출된다. _start함수의 주요 역활은 __libc_start_main함수를 호출하기 위한 전달 인자들을 준비한다. __libc_start_main 함수는 C++ 프로그램을 시작하기 위해서 보안 관련 체크를 수행, 쓰레드 사용을 위한 준비, 프로그램 실행 시 실행해야 하는 루틴 등록, 초기화 함수 호출, main 함수 호출, main 리턴 시 해당 리턴값으로 exit 호출 등을 담당한다.

링커 스크립트
링커 스크립트는 링커가 심볼들을 실행 파일 내부에 여러 섹션에 배치할 때 어떤 식으로 배치할지 알려주는 스크립트이다. 링커 스크립트의 문법은 원하는 섹션 이름을 명시한 뒤에 중괄호 안에 어떠한 심볼들을 배치할 지 써 넣으면 된다.

register_tm_clones는 C, C++에서 Transactional Memory를 지원하기 위한 여러 작업들을 수행한다. 여기서 Transaction은 공유 메모리에서 읽기 및 쓰기를 수행하는 코드 조각을 가리키고 Transactional Memory란 하나의 Transaction을 수행하는 동안 다른 쓰레드에 의해 변경되었는지 검사하고 변경이 없으면 커밋을하고 그렇지 않으면 Transaction을 실패했다고 처리하는 공유 메모리 접근을 제어하기 위한 동시성 제어 구조이다.

컴파일러와 링커가 실행 파일을 생성할 때 사용하는 라이브러리 파일들을 살펴보면 -o 다음에 오는 파일들이 링킹 되는 파일들 이고 -L의 경우 명확한 경로가 지정되지 않은 라이브러리 파일들을 찾을 디렉토리 위치를 지정해 주는것이다. crt1.o 안에는 _start가 정의되어 있고, libc 사용하기 위한 준비를 수행하고 있다. crtbegin.o는 __libc_start_main에서 호출되는 여러가지 초기화 관련 함수들을 정의하고 있습니다. libgcc는 gcc에서 컴파일 되는 코드들에 반드시 링크되어야하는 라이브러리이다.




22. 구글에서는 C++ 을 어떻게 쓰는가?

구글은 오랫 동안 C++를 사용해오고 있으며 C++은 언어 차원에서의 넓은 자유도가 있지만 너무 자유로운 탓에 같은 동작을 수행하는 코드를 너무 다양한 방법으로 작성할 수 있다. 따라서 구글은 Google C++ Style Guide를 따라서 코드 가이드 라인들이 있다.

이름 정하기
클래스와 함수는 CamelCase(대소문자로 띄어쓰기를 구분), 변수나 클래스의 필드 이름들은 모두 snake_case(띄어쓰기를 _로 구분, 모두 소문자), enum 필드의 경우 KEBAB_CASE(띄어쓰기를 _로 구분, 모두 대문자)로 정의한다.

한 줄에 최대 80자
해상도가 낮은 예전에는 80자를 넘으면 한줄에 코드를 다 못 띄웠고 지금도 QHD 모니터의 경우 4개의 차의 띄워 코드를 보기 때문에 80자를 넘지 않는게 좋다. 또한 indentation이 너무 깊어서 80자로 정렬이 제대로 안된다면 애초에 코드 설계를 의심해야한다.

네임 스페이스
기본적으로 모든 코드는 적절한 네임스페이스 안에 들어가 있어야 한다.
헤더 파일에는 절대로 using::..::SomeFunction을 선언하지 않는다. 동일 이름으로 SomeFuntion을 다른 헤더 파일에 선언 되어 있으면 다른 헤더 파일을 거쳐서라도 조금이라도 겹치게되면 심볼 충돌이 발생한다.
헤더든 소소든 절대로 using namespace ...하지 않는다.
using ::SomeFuntion 같이 소스 안에서 alias를 할 때 충돌여지가 없고 모든 경로를 표시하는 fully qualify를 반드시 사용한다.

테스트
모든 소스 파일에는 반드시 테스트 코드가 딸려와야한다. 어떤 클래스를 정의하였다면 반드시 그 정의한 클래스에 대한 유닛 테스트를 작성해야 한다.
소스 코드를 짜는데보다 테스트 코드를 짜는데 더 많은 시간이 걸릴 수 있음에도 안전한 리팩토링, 적절한 예제로 만들어진 유닛 테스트를 통해 남이 코드이해를 쉽게하고 내 코드가 적절히 작동 중이라는 신뢰도를 위해 필요하다.

클래스
struct, class는 C++에서 차이는 없지만 구글의 경우 철저히 명확히 구분해 사용한다.
struct는 간단한 데이터들의 모음을 나타낼 때 사용된다. 오직 데이터만 있고 그 어떠한 로직도 구현하면 안된다. 단순한 로직이라도 구현이 필요한 경우 class를 사용해야한다. 

상속과 구성
구글은 되도록 기본 클래스로부터 상속 받아 파생 클래스로 기능을 구현하는 것보단 구성 방식을 사용하여 클래스를 만드는 것을 권장한다. 상속을 지양하는 이유는 다중 상속의 경우 심볼 충돌이 발생할 수 있고 해당 함수가 어떠한 클래스에 구현되는지 찾기 힘들다. 구성과 비교하여 클래스를 테스트하기도 힘들다. 단 명확한 is-a관계일 때는 상속하는 것이 가능하다.

함수의 결과 값은 결과 값을 보관하는 주소를 돌려 주기보단 함수의 리턴을 바로 돌려주는 방법을 쓰는것을 권장한다.

C++ 표준 라이브러리보다 개선된 absl 라이브러리를 사용하고 exception 대신 예외 상황을 나타내는 absl 객체인 Status를 받는다.
