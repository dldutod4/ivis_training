5월 29일 수요일 

금일은 20-2까지 진행하겠습니다.

17-5. C++ 17 의 std::optional, variant, tuple 살펴보기

optional
기존에 map에서 키값에 대응하는 값이 있는지 확인할 때 맵에 키가 존재하지 않는 경우와 키가 존재하는데 대응하는 값이 빈 문자열인 경우를 제대로 구분하지 못 한다. 또는 맵에 키가 존재 하지 않을 때 디폴트 객체를 리턴해야 한다. 이를 해결하기 위해서 원하는 값을 보관할 수 도, 안할 수 도 있는 클래스가 바로 optional이다. 
optional 객체는 string을 보관하던지 아니면 안하던지 둘중의 하나의 상태만을 가진다. 또한 객체를 보관하는 과정에서 동적 할당이 발생하지 않는다. 아무런 객체도 가지고 있지 않은 빈 optional 객체를 리턴하고 싶다면 그냥 nullopt 객체를 리턴하면 된다. optional 객체가 가지고 있는 객체에 접근하기 전에 반드시 접근할려는 객체가 실제로 값을 가지고 있는지 has_value 함수를 사용하여 확인해야한다. map 에서 사용할 pair 와의 가장 큰 차이점은 optional 객체는 아무것도 들고 잇지 않는 상태에서 디폴트 객체를 가질 필요가 없다는 점이다.
optional 클래스는 일반적인 방법으로는 레퍼런스를 포함할 수 없다는 점이다. 대신 reference_wrapper를 사용하여 레퍼런스 처럼 동작하는 wrapper 객체를 정의하면 된다.

variant
variant 클래스는 one-of를 구현한 클래스 이며 컴파일 타임에 정해진 여러가지 타입들 중에 한 가지 타입의 객체를 보관할 수 잇는 클래스이다. 공용체(union)도 타입을 보관하는 객체로 사용할 수 있지만 현재 어떤 타입의 객체를 보관하고 있는지 알 수 없기 때문에 실제로는 사용하기는 위험하다. variant를 선언할 때 값을 들고 있지 않으면 선언시 첫 번째 타입 인자의 디폴트 생성자가 호출 되기 때문에 반드시 값을 들고 있어야한다. 또한 optional이랑 유사하게 객체 대입 시에 어떠한 동적 할당도 발생하지 않는다. 다만 variant 객체 자체의 크기는 나열된 가능한 타입들 중에 가장 큰 타입의 크기를 따라간다. variant도 아무 것도 들고 있지 않는 상태를 monostate를 사용하여 표현 할 수 있다.

tuple
여러 서로 다른 타입들의 묶음은 tuple을 통해 사용가능하다. 일반적으로 같은 타입의 객체들은 vector를 통해서 사용 가능했다. 만약 여러 개의 타입을 다룰때는 새로운 클래스를 만들어 사용하곤 했다. 이러한 풀편함을 줄이기 위해 tuple을 사용하면 여러 타입들의 집합을 생성할 수 잇다. tuple은 보관하고자 하는 타입드을 주르륵 나열해주면 된다. tuple에서 각각의 원소들을 뽑아낼 때 get을 이용해서 하나씩 추출하면 번거 로웠지만 structured binding을 지원하는 17에서는 auto /* & 혹은 && 도 가능 */ [/* tuple 안에 원소들을 받기 위한 객체*/] = tp;와 같은 방식으로 한번에 추출이나 접근이 가능하다. 대신 오른쪽과 같은 방식으로 tuple의 원소들을 얻어올 때 중간의 원소 하나만은 따로 받지 못하기에 반드시 모든 원소들을 받아야한다.





19-1. Make 사용 가이드 (Makefile 만들기)

리눅스 쉘 상에서 컴파일을 할려면 어떤 파일들을 컴파일 하고, 어떠한 방식으로 컴파일 할 지 직접 컴파일러에게 알려줘야 한다.프로젝트가 거대해지면 일일히 어떻게 컴파일 해야하는지 입력하기 어렵기 대문에 Makefile을 만들어 주어진 방식대로 명령어를 처리하게 한다.

컴파일은 소스 코드를 컴퓨터가 이해할 수 있는 어셈블리어로 변환하는 과정이다.
만약 foo.cc에 정의된 foo함수와 bar.cc에 정의된 bar함수를 main 함수에서 호출할 때를 고려해보자.
main 함수만 들어있는 main.cc를 g++ -c main.cc로 컴파일하게 되면 object file인 main.o를 생성하게된다. main.o에는 main에 대한 어셈블러 코드만 들어 있지 나머지 foo나 bar에 대한 어셈블러 코드는 없다. 따라서 foo와 bar에 대해서도 각각 컴파일 해주어야 한다. 이렇게 foo와 bar를 컴파일 하기만 한다고 바로 main에서 foo와 bar를 가져다 쓸 수 있는 것이 아니다. 각각 foo, bar를 컴파일해서 생성된 foo.o, bar.o를 main.o와 묶어주는 링킹 작업을 해주어야 비로서 main에서 foo와 bar까지를 포함한 정상적인 프로그램이 생성된다.
위의 과정을 일일히 치거나 그대로 쉘 스크립트로 만들면 매우 비효율적이기에 주어진 셀 명령어들을 조건에 맞게 실행하는 프로그램인 make를 사용한다. make는 어떠한 조건으로 명령어를 실행할지 담은 파일인 Makefile를  터미널 상에서 make를 실행하게된 해당 위치에서 찾아서 읽어 수행한다. 어떠한 abc를 make하고 싶으면 make abc를 터미널에 입력하면되고 이 make할려는 어떠한 abc를 target이라 한다.
target을 make할 때 실행할 명령어들의 나열을 recipes라하고 이 recipes 자리에 명령어를 쓸때 반드시 탭 한 번으로 들여쓰기를 해줘야한다.
target을 make할 때 사용될 파일들의 목록을 prerequisties또는 dependency라고 한다. 주워진 파일들의 수정 시간보다 타겟이 더 나중에 수정 되었다면 해당 타겟의 명령어를 실행하지 않는다.
Makefile 내부에서 변수를 정의할 수 있다. 변수를 사용하기 위해서는 $() 괄호 내부에 변수를 넣어줘야 치환이되어 사용가능하다. 정의하지 않는 변수를 참조하면 빈 문자열로 치환된다. 변수를 정의할 때 =를 사용하면 정의에 다른 변수가 포함되어 있다면 해당 변수가 정의 될때까지 변수 값을 정하지 않는다. 반면 :=를 사용해서 정의를 하면 해당 시점에서만 변수값을 확인한다.
make clean을 하게되면 생성된 모든 object 파일과 target을 지워버린다. 하지만 make를 터미널에 입력할 때 해당 디렉토리에 clean이라는 이름의 무엇인가가 있으면 clean을 make할려한다. 따라서 이러한 일을 미연에 방지하기 위해서 .PHONY를 사용하여 make clean 시에 무조건 모두 지우게 한다.
보통 make할 때 1개의 코어만 사용하여 make하게 되는데 target이 매우 크다면 여러 코어를 사용해서 make하는게 좋고 이를 make 명령어의 옵션으로 지원한다.




19-2. C++ 프로젝트를 위한 CMake 사용법

make를 이용해 소스 코드들을 프로그램으로 만들 수도 있지만 프로젝트의 크기가 더 커지거나 여러 플렛폼에서 빌드해야할 경우 빌드 파일을 생성해 주는 CMake를 사용한다. CMake는 프로젝트를 빌드하는것이 아니라 CMake를 통해서 빌드 파일을 생성하면 해당 빌드 파일들로 별도의 빌드 프로그램을 통해서 프로젝트를 빌드하는 것이다.
CMake를 사용하는 모든 프로젝트에는 반드시 프로젝트 최상위 디렉토리에 CMakeLists.txt가 있어야 한다. CMakeLists.txt에는 CMake가 빌드 파일을 생성하는데 필요한 정보들이 들어 있다. 최상단에는 해당 프로젝트에서 사용할 CMake 최소 버전을 명시해준다. CMake는 버전마다 차이가 크기에 2.대 버전일 경우 지원하지 않는 기능이 있을 수도 있다. 따라서 최소 3.0버전 이후를 사용하는것을 권장한다.
생성할 실행 파일을 추가하는 명령은 add_executable(<살행 파일 이름> <소스1> <소스2> ...)로 CMakeLists.txt에 추가하면 된다.
컴파일 옵션을 지정하고 싶으면 target_compile_options(<실행 파일 이름> PUBLIC <컴파일 옵션1> <컴파일 옵션2> ...) 형태로 CMakeLists.txt에 추가하면 된다.
CMake에서의 타겟(target)은 프로그램을 구성하는 요소들이다. 또한 CMake는 각 target에 속성을 정의할 수 있는데 위와 같이 컴파일 옵션을 주는 것도 program이라는 타겟에 컴파일 옵션 속성을 설정하는 것이다. include 폴더에 별도로 속성을 추가할 때 특정 위치에 헤더들이 있다고 target_include_directories(<실행 파일 이름> PUBLIC <경로 1> <경로 2> ...) 오른쪽과 같이 명시할 수 있습니다.

어느 정도 규모가 있는 프로젝트의 경우 각 기능을 전담하는 여러개의 라이브러리 있고 또 이 각각의 라이브러리가 외부의 라이브러리를 가져다 쓰는 형태의 모습을 보이는 경우가 많다. CMake는 이러한 많은 라이브러리 또한 프로젝트에서 추가할 수 있도록 지원을 한다. 각 라이브러리 내부에 CMakeLists.txt를 만들어 주어 만들 라이브러리 이름과 헤더 파일 경로, 컴파일 옵션들을 추가해준다. 직접 만든 라이브러리에서 다른 라이브러리를 사용할 때 직접 만든 라이브러리의 CMakeLists.txt에 사용할 다른 라이브러리를 링크 시켜줘야한다.

file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/*.cc)
add_library(shape STATIC ${SRC_FILES})
CMake도 당연 make처럼 여러개의 파일과 라이브러리를 모두 한번에 빌드해주는 명령어가 위와 같이 존재한다

C++는 언어 상 외부 라이브러리를 불러오거나 설치하는 것이 굉장히 불편하다. 대신 CMake는 FetchContent를 사용하여 왠만한 외부 라이브러리들을 쉽게 불러오고 설치할 수 있다.




20-1. 코드 부터 실행 파일 까지 - 전체적인 개요

C++에서 우리가 작성한 소스코드를 실제로 실행할 수 있는 실행 파일로 변환하기 위해서는 총 3가지 단계를 거쳐야만 한다.
1. #include #define 과 같은 전처리기 매크로들을 처리하는 전처리 단계
2. 각각의 소스 파일들을 어셈블리 명령어로 변환하는 컴파일 단계
3. 어셈블리 코드들을 실제 기계어로 이루어진 object 코드로 변환하는 어셈블 단계
4. 각각의 object 코드들을 한데 모아서 하나의 실행 파일로 만들어주는 링킹 단계
보통은 1,2,3 단계를 뭉둥그려서 진행하여 컴파일 단계 하나로 생각해도 된다.

전처리 단계는 세부적으로 6단계로 나눈다
1. 소스 파일에 있는 공백, 숫자, 알파벳 대소문자, 특수 문자들을 해석한다.
2. \문자를 해석한다.
3. 소스 파일의 주석, 공백, 전처리 토큰들로 분리한다. 전처리 토큰은 헤더 이름, 식별자, 문자/문자열 리터럴, 연산자들로 나뉜다.
4. 전처리 토큰들로 분리 하였으므로 전처리기를 실행합니다. 전처리기는 #include에 지정된 파일 내용을 복사, #define에 정의된 매크로를 사용해 코드를 치환, #if,#ifndef와 같은 구문들을 실행해서 코드를 치환, #pragma와 같은 컴파일 명령어 문들을 해석한다.
5. 모든 문자들은 이전의 소스 코들 문자 셋에서 실행 문자 셋의 문자들로 변경된다.
6. 인접한 문자열을 하나로 합친다.

컴파일 단계는 세부적으로 2단계로 나뉜다.
7. 전처리기 토큰들이 컴파일 토큰으로 변환되고 컴파일 토큰들은 컴파일러에 의해 해석되어 해석 유닛을 각 소스 파일 별로 하나 씩 생성한다.
8. 생성된 해석 유닛을 분석해서 필요로 하는 템플릿 인스턴스들을 확인하고 템플릿들의 정의 위치가 확인되면 해당 템플릿들의 인스턴스화가 진행되고 이를 통해서 인스턴스 유닛이 생성된다.

이후 생성된 컴파일러가 생성한 object파일과 외부 라이브러리 파일들을 모아서 실행 파일을 생성한다.




20-2. 코드 부터 실행 파일 까지 - 컴파일 (Compile)

컴파일 단계의 해석 유닛을 생성하는 부분에서 중요한 규칙이 하나 적용된다. 각 해석 유닛에 존재하는 모든 변수, 함수, 클래스, enum, 템플릿 등등의 정의는 유일해야하고 inline이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일해야한다라는 유일 정의 규칙(One Definition Rule, ODR)이 있다.

변수나 함수의 이름, 데이터 타입, 반환 타입 등을 알려주는 것을 선언이라하고 정의는 선언에서 한 걸음 더 나아가 실제로 메모리를 할당하고 해당 변수나 함수의 내용을 제공하는 것이다. 정의는 선언을 포함한다. 예를들어 int fun();으로 끝 마쳤다면 fun()이 존재한다고 알리는 선언을 한것이고 int fun(){return 0;}라고 하면 실제 fun()이 어떠한 것인지까지 모두 정의 했다고 할 수 있다.

inline 이 아닌 모든 함수의 변수들의 정의는 전체 프로그램에서 유일하다는 이야기는 inline 으로 정의 되어 있지 않는 모든 함수들과 변수들의 경우 한 해석 유닛 안에서 정의가 단 하나 있어야 합니다. inline 키워드가 처음 도입되었을 때 의미는 컴파일러에게 이 함수를 호출하는 문장을 그냥 이 함수의 내용으로 치환시켜도 된다라는 의미였다. C++ 17에서는 일반적인 변수 자체도 여러 정의를 허용한다라는 의미로 사용된다.

각각의 해석 유닛에서 문법이 맞는지 확인하고 ODR 규칙들을 적용하고 나면 컴파일러는 각가의 해석 유닛 별로 실제 어셈블리 코드를 생성한다. 해석 유닛 별로 컴파일 한 후의 object파일은 해당 파일을 특정 위치에 배치할 수 있는 재배치 가능한 파일이 생성된다. 당연 링킹 단계에서 해석 유닛 object 파일을 적절한 위치에 재배치 해주어 프로그램이 원활히 작동할 수 있도록 한다. 링킹 전의 각 해석 유닛의 object 코드에서 만약 호출할 함수가 다른 해석 유닛에 있다면 호출할 함수가 어디에 배치되어 있는 아직은 모르기 때문에 건너뛸 거리를 0으로 설정해 놓는다. 이후 링커는 해석 유닛에 건너뛸 거리들을 가지고 있는 재배치 테이블을 사용하여 호출 함수들의 해석 유닛 object 코드들을 적절히 재배치 한다. 재배치할 때 여러 유형들이 사용되는데 R_X86_64_PLT32는 Procedure Linkage Table를 통해 간접적으로 함수를 호출하는데 사용하는 유형이다. 함수를 호출 할 때 마다 PLT 엔트리를 통해 실제 함수의 주소를 찾아가는 방식이다. R_X86_64_PC32는 위치 독립 코드르 지원하기 위해 사용되고 32비트 상대 주소를 사용하여 함수 호출이나 데이터 참조를 수행한다.
