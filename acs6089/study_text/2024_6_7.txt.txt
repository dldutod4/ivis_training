6월 7일 금요일


confluence - 02.C++ d.Thread


Introduction to Concurrency

여러 작업이 동시에 시행되는 듯한 Concurrency(동시성)은 C++11에서 지원되었다. C++11에서 Concurrency을 구현하기 위해 POSIX나 pthread를 사용해야만 했다. 하지만 앞선 두개의 라이브러리를 사용하면 해당 라이브러리가 제공하는 기본 셋 표준 언어가 부족하여 이식성에 문제가 발생했다. C++11에서 지원하는 Concurrency는 thread, C++ memory model, conditional variables, mutex 등을 포함하고 있었고 이는 C++17에서 많이 바뀌게 된다. 추가적으로 SL에 있는 병렬 알고리즘들이 멀티쓰레드 코드에서 매우 향상되었다.
Concurrency이란 여러 작업이나 프로그램들이 동시에 작동하는 중, 서로간 통신을 할 때 발생한다. 이러한 Concurrency을 구현하기 위한 여러가지 방법이 존재하는데 이는 아래의 설명들과 같다.

Shared memory
공유 메모리란 컴퓨터 환경에서 여러 프로그램이 동시에 접근할 수 있는 메모리이다. 프로그램간 통신(IPC)나 공유 라이브러리를 불필요하게 복사하는 것을 막기 위해 고안되었다. 파일 시스템을 사용하는 파이프 통신, Unix Domain Socket 같은 IPC들과 다르게 공유 메모리를 통한 IPC는 매우 빠른 메모리를 사용하여 일반 메모리에 접근하는 것과 동일한 속도로 프로세스 간 통신이 가능하다. 단 통신을 할 프로세스들은 당연 같은 물리 메모리를 사용하는 같은 단말기 안에 있어야한다. 또한 같은 물리 메모리를 사용하더라도 각각의 프로세서의 캐시 일관성 문제를 주의해야한다. 여기서 캐시 일관성 문제란, 최근 컴퓨터 또는 단말기는 하나의 CPU안에 여러개의 물리 프로세서(멀티 코어)를 갖고있고 매우 빠른 프로세서와 상대적으로 느린 일반 메모리 사이에는 캐시라는 중간에 자주 쓰이는 값이나 변수 또는 주소들을 저장하는 매우 빠른 메모리가 있다. 여기서 프로세서 A가 일반 메모리 주소 c에서 값을 가져와 캐시에 넣고 매우 빠르게 자주 사용하며 중간에 일반 메모리에 값을 다시 넣어줄때 프로세서 B가 같은 일반 메모리 주소 c에 있는 값에 접근하여 사용하면  프로세서 A에서 끝난 작업 값과 프로세서 B에서 끝난 작업 값이 일치 하지 않는 문제를 캐시 일관성 문제라고 한다.

Message pass
프로세스간 통신은 위와 같이 공유 메모리를 통해서만 이루워지는게 아니라 호출 프로그램이 프로세스에 해당 프로세스와 지원 인프라를 사용하여 적절한 코드를 실행하게하는 방식으로도 통신이 가능하다. 이는 공유 메모리 처럼 같은 프로세스가 같은 단말기 위에 있지 않더라도 메세지를 주고 받을 수만 있다면 다른 단말기에 있는 프로세스에게도 전달이 가능하기에 더 넓은 확장성을 가지고 있다.

Process
프로세스란 동일한 단말의 다른 프로세스와 격리되어 실행 중인 프로그램 하나의 객체이다. 비슷한 단어인 프로세서(Processor)는 실체를 갖고 연산 유닛, 수행 유닛과 캐시 등이 포함되며 프로세스를 실제로 수행하는 물리적 연산, 수행 유닛이니 잘 구분하자. 단 프로세스도 저장된 프로그램을 불러오고 내부의 데이터를 처리해야 하기에 단말기의 메모리 일부를 개별적으로 갖고 있다. 이 덕분에 프로세스는 해당 프로그램을 실행하기 위해 독립된 메모리와 프로세서를 갖는 하나의 단말기 같이 작동하게 해준다. 따라서 프로세스들을 하나 하나의 단말이라 생각하면 서로의 정보 교환을 위해서는 별도의 조치가 필요하고 앞서 이야기한 공유 메모리나 메세지 패스를 통해 통신한다. 

Thread
쓰레드는 어떠한 프로세스 내에서 실행되는 흐름의 단위이다. 멀티 프로세스에서 각 프로세스는 독립적으로 실행되며 각각의 개별 메모리를 갖고 있는 것과 다리 멀리 쓰레드는 같은 프로세서 내에서 진행되는 것이라면 해당 프로세스 내의 메모리를 공유하여 사용할 수 있다. 또한 프로세스 간의 전환시 발생하는 오버헤드보다 쓰레드 간 전환시 발생하는 오버헤드가 훨씬 적다. 멀티 쓰레드의 최대 장점은 여러 개의 CPU가 한 프로세스의 여러 쓰레드를 하나씩 담당하는 방법으로 처리 속도를 향상 시킬 수 있다. 대신 멀티 쓰레드의 단점에는 각각의 쓰레드 수행 순서는 사용자가 알기 어렵고 보통은 OS가 자동으로 처리한다는 것이다. 쓰레드 실행 조건에 따라 결과가 다르게 나오는 것을 경쟁 조건이라고 하며 이 문제를 예방하기 위해 세마포어나 뮤텍스를 사용하여 하나의 쓰레드가 우선적 또는 독점적으로 메모리 자원을 활용하게 하여 해결한다. 

Time-slicing
어느 단말기 안에 프로세서는 2개만 있는 상황에서 3개의 쓰레드를 동시에 처리해야할 경우를 가정해보자. 여기서 하나 쓰레드가 2초가 걸린다하면 하나의 프로세서를 점유해서 한번에 끝까지 수행할 수 있으나 이럴 경우 하나의 프로세서는 4초에 나머지 하나의 프로세서는 2초에 작업을 마치게 된다. 3개의 쓰레드가 모두 처리되는데 결국 4초가 걸린것이다. 이때 쓰레드 마다 2분활 가능하다고 하면 프로세서 A,B는 각각의 하나의 쓰레드 작업을 마치고 나머지 하나의 쓰레드를 반씩 수행하면 3초에 쓰레드 3개를 모두 처리가 가능해진다. 이렇게 하나의 쓰레드를 잘라내어 적절하게 배치하는 것을 Time-slicing이라고 한다.

Concurrency vs. parallelism
동시성과 병렬성는 매우 혼동되기 쉬운 개념이나 그 차이점을 확실히 알 필요가 있다. 먼저 병렬성은 여러 작업을 동시에 실행하지만 각각의 작업은 각기 다른 데이터를 가지고 수행된다. 반면 동시성은 여러 작업이 실행되며 같은 데이터를 기반으로 수행하는 것이라고 보면된다. 당연 동일 데이터를 여러 프로세서가 동시에 작업하면 빠르게 끝날 것 같지만 아쉽게도 항상 그러지는 안는다. 공유 메모리에서나 쓰레드에서 설명하였듯이 경쟁 조건이라는 문제가 발생하여 이를 잘 제어해줄 필요가 있고 결국에 하나의 변수에 대해서 처리해야하면 단일 프로세서가 처리하는 것과 동일한 또는 더 많은(쓰레드 스위칭 시 발생하는 오버헤드) 시간이 걸리게된다.


