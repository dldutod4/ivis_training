5월 14일 화요일

4-6. 클래스의 explicit과 mutable 키워드
5-1. 내가 만든 연산자 - 연산자 오버로딩
5-2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩
위의 단원을 학습하였습니다.




4-5. 내가 만드는 String 클래스 문제1 문제2
5-1. 내가 만든 연산자 - 연산자 오버로딩 문제2
위의 문제를 코딩해 보았습니다.

이상 금일은 회식이 있어서 퇴근하겠습니다.


4-6. 클래스의 explicit과 mutable 키워드

암시적 변환(implicit conversion)
<자료형> <사용자 정의 함수>(<클래스 선언> <사용자 정의 함수 생성자>)
ex)void something(Mystring s){}
위의 형태로 선언 후 something("abc") 와 같이 사용해도 Mystring s의 유사한 생성자 있을 시 해당 생성자를 통해 자동으로 something의 입력으로 사용된다.

explicit는 명시적이라는 의미 implicit 절대적의 반대 의미
위와 같이 암시적 변환으로 사용되는 것을 막기 위해 explicit 라는 명령어를 사용한다
explicit <사용자 정의 함수 생성자> 와 같은 형식으로 사용되면 해당 생성자는 암시적 변환으로 사용되지 않는다.

mutable 는 변이 가능한 이라는 의미
mutable로 선언된 함수 또는 변수는 const로 선언된 함수 또는 변수를 변경할 수 있게한다.
고정되어 있는 변수 const를 mutable로 유동가능하게 쓰는 이유는 이미 램에 올라가 있는 프로그램 내부에서 고정적인 값을 변경할 수 있게하기 위해서 사용
-> const 변수 변경을 위해 느린 데이터 베이스에 있는 정보를 업데이트하기 위해서 새로 프로그램을 실행시키는 작업보다 일부만 대체하는게 빠르기 때문



5-1. 내가 만든 연산자 - 연산자 오버로딩

같은 이름의 함수를 인자만 다르게 사용하는 것을 '함수를 오버로딩 했다'라고 부르는 것 처럼 기본 연산자에게도 오버로딩을 할 수 있다
<리턴 타입 자료형> operator<연산자>(<연산자가 받는 인자>){}
ex) bool operator==(Mystring& str){}




5-2. 입출력, 첨자, 타입변환, 증감 연산자 오버로딩

friend 는 다른 클래스나 함수들의 friend로 정의하여 private로 정의되어 있는 변수나 함수에 접근을 가능하게하는 명령어
단, friend 라고 선언한 클래스는 friend 대상의 private에 접근할 수 있지만 반대의 경우에는 불가능함

오버로딩을 하는 함수들 중 같은 작동이 가능한 여러개의 함수가 발생할 수 있다. 여기서 리턴값을 기준으로 선택적으로 실행하게 할 수 있다.
자기 자신을 리턴하지 않는 경우 외부 함수로 선언하는 것이 원칙, 반대의 경우에는 맵버 함수로 선언하는 것이 원칙

wrapper 란 무언가를 포장하는 클래스, 어떤 경우 기본 자료형을 객체로써 다루어야 할 때 이들을 클래스로 포장해서 각각의 자료형 객체로 사용하게 wraper 클래스 사용
이렇게 wrapper 클래스로 사용할 때 자료형 변수들에게 사용하던 연산자들을 적용할 시에 일일이 모두 오버로딩할 수 있지만 너무 많은 시간과 노력을 소모
기존 자료형 변수들이 사용하던 연산자를 활용하고 싶으면 operator <변환하고자 하는 자료형>() {} 와 같이 사용하면된다

오버로딩된 전위 후위 연산자들은 아래와  같이 구별한다.
operator++(); -> 전위 연산자 == ++x
operator++(int) -> 후위 연산자 == x++
단, 전위 증감 연산의 경우 값이 바뀐 자신을 리턴해야하고, 후위 증감 연산의 경우 값이 바뀌기 전의 자신을 리턴해야한다.

두 개의 동등한 객체 사이에서의 이항 연산자는 맴버 함수가 아닌 외부 함수로 오버로딩 하는것이 좋다.
ex) operator+= 는 이항 연산자 이지만 operator+=(const Complex&)로 사용하것이 좋다.

두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다던지 등의 동등하지 않는 이항 연산자는 맴버 함수로 오버로딩 하는 것이 좋다
ex) operator++
