5월 20일 월요일

6-1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속

표준 string 클래스
"<넣고 싶은 문자열>" 오른쪽과 같이 사용하게 되면 해당 문자열은 const char *로 생성자를 호출한다.
표준 string 클래스는 연산자 오버로딩을 통하여 다양한 비교 연산자나 증감 연산자를 문자열에 적합한 형태로 사용할 수 있도록 지원한다.
ex) 비교 연산자는 일반적으로 주소를 비교하는 형태였다. 문자열이 같은지 다른지를 판별할려면 strcmp 같은 별도의 함수를 사용해야한다.

상속(Inheritance)
새로운 클래스를 만들때 기존에 사용하는 변수는 같고 일부만 추가하는 경우 상속을 통해 기존 부분은 그대로 사용하고 추가된 부분만 작성해주면 된다.
이와 같이 다른 클래스의 내용을 그대로 포함할 수 있는 작업을 가능토록 하는 것을 상속이라고 한다.
기존의 클래스 = 기반 클래스(Base), 기반 클래스의 여러 함수 및 변수를 상속 받는 클래스 = 파생 클래스(Derived)
ex) class <상속 받는 파생 클래스 이름> : public <상속 해주는 기반 클래스 이름>

파생 클래스가 기반 클래스를 통해 상속받아 생성자를 호출할때 기반 클래스의 생성자를 호출해서 기반 클래스의 생성자를 먼저 처리한 다음에 파생 클래스의 생성자가 실행되어야 한다.만약 기반 클래스 생성자 처리를 해주지않으면 디폴트 생성자가 호출된다.

파생 클래스 객체를 만들때 먼저 기반 클래스의 객체를 만들고 다음으로 파생 클래스를 만들기 때문에 기반 클래스를 만들며 진행되는 과정이 모두 진행된 후에 파생 클래스생성이 진행된다.

만약 파생 클래스와 기반 클래스에 동일한 함수 명이 존재한다면 파생 클래스 사용시 파생 클래스 내부의 함수를 사용하며 이를 오버라이딩이라 한다.
파생 클래스 내부의 함수가 기반 클래스 내부의 함수를 오버라이딩했다.

private : 자기 자신만 접근 가능
protected : 상속받은 클래스에서 접근 가능하고 그외의 기타 정보는 접근 불가능
public : 누구나 접근 가능

ex) class <상속 받는 파생 클래스 이름> : <public || protected || private> <상속 해주는 기반 클래스 이름>
위와 같이 상속 받을 때 private로 상속을 받게 되면 기반 클래스의 모든 접근 지시자들이 private로 인식되고, protected로 상속을 받으면 public 접근 지시자들은 protected로 인식하고, public으로 상속을 받으면 기반 클래스의 모든 접근 지시자들을 그대로 인식하게 된다.



6-2. 가상(virtual) 함수와 다형성

상속을 도입한 이유는 해당 기능을 통해 객체지향프로그래밍에서 추구한는 실제 객체의 추상화를 좀 더 효과적으로 할 수 있게하기 위함이다.
상속이라는 것이 없는 C에서는 구조체 사이의 관계를 표현할 수 없었다. 반면 C++은 상속이 가능해지면서 기반 클래스와 파생 클래스 간의 관계가 확실해 졌다.
모든 상속 관계는 <기반 클래스> is a <파생 클래스>라고 볼 수 있다. 또한 클래스가 파생되면 파생될 수 록 더 특수화(구체화;specialize)된다.반대로, 기반으로 올라가면 올라갈 수 록 일반화(generalize)된다.
모든 클래스 관계를 is a 관계로만 표현할 수는 없다. 자동차가 브레이크, 오디오, 엔진 등을 갖는 것 처럼 has a 관계로 쉽게 표현이 가능하다.

업 캐스팅 : 파생 클래스에서 기반 클래스로 캐스팅 하는 것
반대의 다운 캐스팅은 함부로 하지 않는 것을 기본으로 한다. 왜냐하면 파생 클래스는 이미 기반 클래스가 처리된 생성된 이후에 생성되기 때문에 기반 클래스에 접근하는 것이 문제가 없지만 반대의 경우 기반 클래스는 생성되었으나 파생 클래스는 생성되어 있지 않을 수도 있기때문에 접근이 되지 않을 가능성이 있어 다운 캐스팅은 함부로 하지 않는다. 그래도 할 필요가 있을 경우 강제적으로 타입 변환을 통해 접근하는 것이 가능하다.

dyanmic_cast
위와 같이 상속 관계에 있는 두 포인터들 간에 캐스팅을 해주는 dynamic_cast가 존재한다.


**virtual**
기본적으로 컴파일을 할때 어떤 함수가 실행될 지 정하지만 virtual을 사용하면 컴파일 시가 아닌 런타임 시에 정하게 하고 이를 동적 바인딩(dynamic binding)이라 부른다. 컴파일 할 때 어떤 함수가 실행될지 정하는 것을 정적 바인딩(static binding)이라 한다. 

오버라이딩하는 경우 파생 클래스의 함수가 기반 클래스의 함수의 이름 뿐만 아니라 형태나 꼴도 정확히 같아야한다.
파생 클래스에서 기반 클래스의 가상 함수를 오버라이드하는 경우, override 키워드를 통해서 명시적으로 나타낼 수 있다. 해당 키워드는 실수로 오버라이드를 하지 않는 경우를 막을 수 있다. 오버라이딩을 하면서 함수의 형태가 비슷하여 넘어가 컴파일 시에는 모르는 오류가 실제 런타임에서 발생할 수 있지만 override 키워드로 명시하면 실수로 비슷한 함수로 작성해서 오버라이딩 되지 않으면 에러를 띄워준다.
ex) void <오버라이드 함수> override {}

하나의 메소들르 호출했음에도 여러가지 다른 작업들을 하는 것을 다형성(polymorphism)이라 한다.ㄴ
