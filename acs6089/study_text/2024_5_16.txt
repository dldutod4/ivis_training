2024년 5월 16일 목요일

5-3. 연산자 오버로딩 프로젝트

C++ 스타일의 캐스팅은 크게 알아서 캐스팅하는 암시적 캐스팅과 직접 지정하여 캐스팅하는 명시적 캐스팅이 존재
암시적 캐스팅의 경우 int와 double 변수와의 덧셈을 수행할 때, int 형 변수가 자동으로  double 변수로 캐스팅 되는 것을 말하고, 명시적 캐스팅의 경우 void* 타입의 주소를 특정 구조체 포인터 타입의 주소로 바꾼다던지 등의 캐스팅이 있다.

static_cast : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
const_cast : 객체의 상수성을 없애는 타입 변환. ex) const int -> int 의 형태로 변환
dynamic_cast : 파생 클래스 사이에서 다운 캐스팅
reinterpret_cast : 위험을 감수하고 한느 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등

<원하는 캐스팅 종류><바꾸려는 타입>(<바꾸려는 타입 대상>)
static_cast<int>(float_val)

이중포인터 등 다중 포인터를 이용해서 다차원 배열를 만들시 메모리가 허용하는 한 크기가 매우 큰 배열도 만들 수 있다.
하지만  Address 구조체를 도입한다면 굳이 int** 등의 정해진 차원에 해당하는 다중 포인터 대신 void* 하나로 정리가 가능
top 이라는 address 객체 도입. top은 맨 위에 배치되어 level 값은 0이고 다음에 들어 오는 레벨1 인 Address 배열 시작 주소가 배치됨
이렇게 계속 배치 되다가 맨 마지막 칸에는 Address 배열이 아닌 실제 값들이 저장되는 int 배열의 시작 주소가 들어감
위와 같이 N 차원 배열을 생성하면 Address 들은 총 0 레벨 부터 N-1 레벨 까지 생성되며 N-1 레벨에는 실제로 보관할 데이터에 해당하는 배열의 시작 주소값이 들어가고 N-2레벨까진 다음 레벨의 Address 배열의 시작 주소값이 들어간다.

처음 해당 배열을 생성하기전 클래스에서 몇 차원의 배열이 생성될지는 임의로 결정된다. 따라서 아직 결정되지 않은 배열을 초기화하기 위해서 재귀 함수를 사용하여 배열을 생성하면서 입력되는 차원에 따라 재귀 함수를 사용해 초기화해야한다.

재귀 함수를 구성하기 위해서 2가지만 기억하자
1. 함수에서 처리하는 것, 즉 현재 단계에서 다음 단계로 넘어가는 과정은 무엇인가?
2. 재귀 호출이 종료되는  조건은 무엇인가?

배열을 생성하기 위해 해당 배열(Array) 클래스에서 재귀 함수를 사용할 때 2번에 해당하는 부분은 명확하다. 재귀 함수 호출 종료 조건은 Address 배열의 레벨이 N-1 또는 dim-1 이면 다음(next)에는 int 배열의 데이터가 들어가게 되므로 재귀 호출을 끊어 주어야한다.
1번에 대한 것도 현재 n 레벨의 Address라면 이들의 next에 해당하는 n+1 레벨의 Address를 지정해주고 이 각각의 원소에 대해 처리하도록 재귀 함수가 작동하도록 한다.


operator [] 인식 문제
1개의 의 []를 취하는 연산자는 있어도 N개의 [] 들을 한번에 인식하는 연산자는 없다
[] 연산자의 리턴과 대상을 처리하는 과정
ex) arr[1][2][3][4]
제일 먼저 arr[1]이 처리 되며, 첫 번째 차원으로 1을 선택했다는 정보가 담긴 어떠한 객체 T를 리턴
그러면 (T)[2][3][4]가 되고 T[2]가 처리되며 두번째 차원으로 2를 선택했다는 정보가 담긴 T'을 리턴
그러면 (T')[3][4]가 되고 T'[3]가 처리되며 세번째 차원으로 3을 선택했다는 정보가 담긴 T''을 리턴
그러면 (T'')[4]가 되고 T''[4]가 처리되며 네번째 차원으로 4를 선택했다는 정보가 담긴 T'''을 리턴
이렇게 최종적으로 리턴된 T'''가 int 타입임을 구현해야한다

operator[]가 Array& 타입이고 int&를 리턴한다면 1차원 배열에 대해서는 리턴을 할 수 있지만 고차원 배열에 대해서는 처리하지 못한다.
따라서 int 처럼 동작하지만 int 가 아닌 클래스인 int 의 Wrapper 클래스를 사용하여 해결한다.
위의 Array 클래스에서 operator[] 가 int 의 Wrapper 클래스 객체를 리턴하게 할때, 실제 int 값에 접근할 때에는 int 변수 처럼 행동하고, 위의 T, T', T'' 등 처럼 원소에 접근해 가는 중간 단계의 산물일 경우, 그 중간 단계의 정보를 포함하는 int 의 Wrapper 를 만들어 사용하면 된다.

앞서 이야기한 모든 기술을 사용하여 arr[1][2][3]을 입력하면
맨 먼저 arr[1] 은 level 1 짜리 Int 객체 T를 리턴하여 T[2][3]을 리턴하고
다음 단계에세 level 2 짜리 Int 객체 T'를 리턴하여 T'[3]을 리턴하고
그 다음 level 3 짜리 Int 객체 T''을 리턴 하는데 해당 T''의 data가 가리키는 포인터들은 이전처럼 Address를 가르키는게 아닌 실제 자료들이 저장된 int 배열의 시작 주소를 가르킨다.

별도의 2개의 클래스가 서로를 사용할 경우 friend 선언이나 포인터를 정의하는 등의 행동은 가능하지만 구체적인 상대 클래스 내부의 정보를 사용하는 경우 반드시 상대 클래스의 정의가 선행 되어야만 합니다.

위에서 완성한 N차원 배열 객체의 모든 원소에 접근할려면 N 중 for문을 사용해야 접근이 가능
하지만 포인터 ptr이 ptr++를 이용해서 다음 원소를 가르켰듯이 위의 N차원 배열에서도 이와 유사한 기능을 구현할 수 있다.
이를 구현하는 방법은 example code의 Iterator 클래스를 참고하자.
