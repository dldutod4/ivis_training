6월 5일 수요일


Black duck Protex

Black Duck Protex는 Synopsys사의 오픈소스 규저을 관리하기 위한 솔루션이다. 개발중인 소프트웨어가 어떤 오픈소스를 사용하고 있고 어디서 사용하고 있는지, 사용한느 오픈소스의 라이센스는 무엇인지, 라이센스룰 위반하지 않기 위해서는 무엇을 해야하는지 등을 분석해주고 리포트로 출력해준다.
위와 같은 오픈소스에 대한 정보를 github 등 다양한 오픈소스 웹사이트를 통해 정보를 취합하여 데이터베이스화 하여 가지고 있다.
Component scanning : 개발중인 소프트웨어와 Black Duck 데이터베이스에 있는 모든 OSS Components와 빠르게 비교한다. 이는 정확하게 일치 하지 않을 수 있고 그럴 경우 수동으로 일치하지 않는 패키지의 이름 및 버전을 확인하거나 누락되거나 잘못된 정보가 없는지 확인한다. 수동적으로만 처리하는게 아니라 OSS Componets 목록을 업데이트하거나 설정을 조정하여 최대한 많은 오픈소스들의 라이센스들을 파악한다. 만약 일치하는 항목이 여러개라면 가장 적합해보이는 항목을 선택한다.
Compnent scanning은 오픈소스 프로젝트에서 릴리즈 된 이후 변경되지 않은 파일들인 Unmodified, 다른 수정 없이 이름만 변경된 파일인 Renamed, 오픈소스 프로젝트에서 릴리즈된 후 압축/재컴파일된 파일들인 Compressed and/or recompiled, 오픈소스 프로젝트에서 릴리즈된 후 수정되거나 rebundled된 파일들인 Modified or rebundled등을 식별할 수 있다.




Dynamic memory

어떠한 변수를 저장할 때 (특히 문자열의 경우) 변수 저장 공간의 크기를 미리 컴파일 타임 이전에 지정해 놓게된다면 작은 크기의 입력이 들어 왔을 때는 남은 저장 공간이 낭비되고 반대로 큰 크기의 입력이 들어오면 저장하지 못하는 문제가 발생한다. 따라서 이 문제를 해결하기위해 변수 저장 공간의 크기를 컴파일 타임에 지정해는 것이 아닌 실행 타임에서 결정할 수 있게하는 것이 동적 할당 (Dynamic memory)라고 한다. 이러한 동작할당은 변수 크기에만 사용하는 것이 아니라 프로그램 시작 초기에만 필요한 저장 공간을 초기에 다 사용하고 나면 해체하는 방법으로 메모리를 더 효율적으로 쓰게해준다.

C에서는 동적 할당을 위해 malloc, calloc, realloc/free 같은 함수를 사용하였고 C++에서는 동적 할당을 위해 new/delete를 사용한다. C++에서는 new/delete를 사용하여 생성 및 소멸을 해주기 때문에 반드시 new/delete를 사용해야한다. C++은 C의 모든 명령어를 사용할 수 있기때문에 malloc, calloc, realloc/free 모두 사용할 수 있으나 new/delete로 완전 대체가 가능하므로 new/delete사용을 권장한다.
C++에서 동적 할당 new를 사용하다가 메모리 할당에 실패한다면 exception(std::bad_alloc)이 발생한다. 할당이 실패하는 원인은 다양한데 시스템 자원의 부족이거나 프로그램 단에서는 잘못된 메모리 관리, 무한 루프나 과도한 할당의 반복, 부적절한 데이터 구조의 사용등이 있다. 이러한 문제를 해결하기 위해서는 메모리 사용량을 모니터링하거나 프로파일링 도구를 사용하여 어디서 메모리 할당이 일어나고 실패하는지 분석해야한다. 또한 메모리 할당에 실패시 exception이 발생하는데 프로그램 스퀀스 상의 문제라 판단되면 catch를 통한 예외 처리를 시도해 볼 수 있다. 그외에 프로그램 실행 중 이미 메모리 단편화(메모리를 할당, 해제하는 과정에서 메모리 블록들이 불규칙하게 나뉘어져 사용가능한 메모리가 조각나는 현상)가 많이 진행되어 연속된 메모리를 할당 하지 못할 때 동적 할당이 실패할 수 있다. 이 경우에는 프로그램이 시작하자마자 heap 영역에 미리 큰 메모리를 할당하여 문제를 해결할 수도 있다.
C++에서 new[]/delete[]를 통해서 다차원 배열을 만들 수 있지만 STL에서 제공하는 컨테이너인 array, vector, list와 같은 컨테이너들을 사용하는 것이 좋고 2차원 동적 배열이 필요하면 vector<vector<T>>와 같이 사용하자.
동적 할당은 stack이 아닌 heap 영역에 메모리를 할당하게 된다. 이 영역은 유저가 직접 관리하는 영역이기 때문에 메모리 할당을 해주었으면 반드시 해제해 주어야한다. 할당 후 제대로 해제를 해주지 않으면 메모리 누수가 발생하여 에이징 테스트, 기타 마일드스톤 이벤트 때 매우 크리티컬하게 발견되기 때문에 동적 할당을 쓸 일이 있으면 항상 주의하자.
위와 같은 메모리 누수를 방지하기 위해 사용한 new의 갯수와 delete의 갯수의 짝을 맞추며 throw/exception과 같은 분기를 조심하자. new를 이용해 메모리를 할당 후 다음 모든 라인에서 exception이 발생할 수 있는지 확인 해야한다. exception이 존재할 가능성이 있다면 catch 블록에서 짝에 맞는 delete를 해주어야한다. 틈틈히 valgrind 같은 메모리 누수 검사 툴을 활용하여 누수 위험을 확인한다.
동적 메모리는 항상 힙에 할당 되지만 포인터는 단순 변수이기 때문에 스택에 있을 수도 있고 힙에 있을 수도 있다. 이를 이용해 스마트 포인터는 포인터와 기타 포인터 관리에 필요한 사항을 객체로서 스택에서 관리하여 스코프를 벗어나면 자동으로 해제 되도록 해준다. 스코프를 벗어나면 메모리가 해제되기 때문에 exception에서도 안전해진다. 또한 일반적인 포인터들이 여러 위치에서 동일한 포인터를 복사, 참조 할때 생기는 에일리어싱 문제(데이터 일관성 회손, 디버깅의 어려움)가 발생할 수 있는데 스마트 포인터는 참조 되는 횟수를 자동으로 기록하여 자신을 더 이상 참조하는 대상이 없으면 자동으로 메모리를 해제하여 해결한다.





Data structures

SW Compnent를 디자인할 때 어떠한 데이터 구조를 선택하냐는 매우 중요하다. 코드의 로직이 선택한 컨테이너랑 상관없이 작동함에도 코드의 작동 시간과 성능에 지대한 영향을 미친다. 따라서 프로그램을 디자인할 때 C++에서 제공하는 컨테이너 내부에서 어떤 동작을 제일 많이하는지 고려해야한다. 랜덤 원소 접근, 순서 원소 접근, 원소 값 교체, 원소 자체를 교체, 원소 탐색, multi-thread 접근 등의 동작을 STL에서 제공하는 컨테이너들이 수행하는데 걸리는 시간이 각자 다르므로 자주 수행하는 작업이 있다면 해당 작업의 소요시간이 가장 짧은 컨테이너 중에 하나를 선택해야한다.

Array
Array는 동일한 데이터 타입의 요소들이 연속적으로 메모리에 배치된 자료구조이다. 배열은 일반적으로 선언시 크기가 정해지며 연속적으로 저장되어 있어서 다른 자료 구조에 비해서 오버헤드가 적고 특정 요소로의 접근하는 것이 매우 빠르다는 장점이 있다. 단 크기를 변경하거나 원소를 삭제 삽입할려면 새로운 Array를 만들어 그곳에 기존 Array를 복사해 넣는 방식으로 작동하기에 시간이 많이 걸리고 실제 할당한 공간보다 적게 사용하면 나머지 메모리 공간이 낭비되는 단점이 존재한다.

Linked list
Linked list는 데이터 요소들이 순차적으로 연결된 선형 자료구조이다. 각각의 요소는 노드라고 불리며 각 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다. 포인터로 각 노드가 연결되기 때문에 동적으로 새로운 노드를 만들어 기존의 리스트에 붙이는 방식으로 삭제 및 삽입이 매우 빠르고 쉽다. 또한 연속하는 메모리 공간이 아니라 멀리 떨어진 메모리 공간에 할당할 수 있기 때문에 메모리 단편화 문제에서 자유로운 편이다. 단 리스트 내부에 랜덤한 원소에 접근하기 위해서는 첫 노드부터 목표 노드까지 순차적으로만 접근할 수 있기 때문에 탐색시간이 느리고 데이터와 포인터를 가지고 있기 때문에 데이터만 가지고 있는 array에 비해서 메모리 오버헤드가 있는 편이다. single linked list는 각 노드가 단방향으로 doubly는 각 노드가 양방향으로 circular는 각 노드가 양방향 또는 단방향으로 연결되어 있으며 첫 노드와 끝 노드가 연결되어 있는 구조이다.

stack
stack은 Last In, First Out 원칙에 따라 데이터가 저장되고 삭제되는 선형 자료구조이다. 따라서 스택은 맨 위쪽인 top부분에서만 데이터의 삽입과 삭제가 일어나는 구조이다. 또한 스택은 프로그램 마다 끝 부분에 자동으로 할당되고 크기또한 동적이다. 단순하고 삽입 삭제가 매우빠르며 다양한 응용이 가능하다는 장점이 있다.

tree
트리는 노드들로 구성된 계층적 자료구조로 하나의 루트에서 시작하여 자식 노드들로 분기되며 각 자식 노드들은 다시 각자 자식 노드들을 가질 수 있다. 그래프의 한 형태이며 무방향이며 사이클이 없는 연결 그래프이다. 각 노드를 연결하는 선을 간선, 루트 노드 레벨을 0이라고하고 각 노드가 루트에서의 거리를 나타내는 레벨, 루트로 부터 가장 거리가 먼 노드의 레벨을 높이라고 한다. 트리의 종류로는 이진 트리, 이진 탐색 트리, 균형 이진 트리, 힙, n차 트리 등 다양한 종류의 트리가 있다.

Binary Tree
바이너리 트리는 각 노드가 최대 2개의 자식 노드를 갖는 트리 구조이다. 모든 노드가 0개 또는 2개의 자식 노드를 갖고 모든 리프 노드가 동일한 레벨에 있는 이진 포화트리, 마지막 레벨을 제외한 모든 레벨이 완전히 채워져 있으며 마지막 레벨의 노드들은 왼쪽부터 차례로 채워져 잇는 완전 이진 트리, 모든 리프 노드가 동일한 레벨에 있고 모든 내부 노드가 정확히 두개의 자긱 노드를 가지는 정 이진 트리, 모든 노드의 왼쪽과 오른쪽 서브트리의 높이 차이가 최대 1인 트리인 균형 이진 트리, 왼족 자식 노드값이 부모 노드 값보다 작고 오른쪽 자식 노드의 값이 부모 노드의 값보단 큰 트리인 이진 탐색 트리 등이 있다.

Binary Search Tree
이진 탐색 트리는 왼족 자식 노드값이 부모 노드 값보다 작고 오른쪽 자식 노드의 값이 부모 노드의 값보단 큰 성질을 갖는 이진 트리이다. 앞선 성질을 가지고 있기 때문에 검색, 삽입, 삭제 연산을 지원하며, 많은 알고리즘과 데이터 구조에서 사용된다. 이진 탐색 트리는 각 노드의 왼쪽 서브트리는 해당 노드보다 작은 값으로 구성되고, 오른쪽 서브트리는 해당 노드보다 큰 값으로 구성된 정렬된 구조를 가지고 있으며 원하는 값을 찾는데는 평균적으로 O(log n)의 시간이 소요되며 삽입과 삭제에도 평균적으로 O(log n)의 시간이 소요된다.

Red-Black Tree
레드 블랙 트리는 이진 탐색 트리 중 한 종류로 각 노드는 레드 또는 블랙 중 하나의 색을 가지고 루트 노드는 블랙이다. 또한 각 리프 노드는 블랙이고 레드 노드의 자식 노드는 모두 블랙이다.(따라서 레드 노드는 연속해서 나타날 수 없다) 어떤 노드로부터 시작되어 그에 속한 모든 리프 노드에 도달하는 경로는 모두 같은 개수의 블랙 노드를 포함하는 특징을 가지고 있다. 레드 노든의 부모와 형제 노드를 블랙으로 부모의 부모를 레드로 변경하여 트리의 균형을 유지한다. 검색, 삽입, 삭제 모두 worst case에서도 O(log n)의 시간 복잡도를 지닌 매우 균형 잡혀있고 트리의 높이를 최소화하여 효율적인 데이터 구조를 C++ STL에서는 map, set으로 제공한다. 

Heap
힙은 완전 이진 트리의 한 형태로 각 노드의 값이 특정한 규칙을만족하는 데이터 구조이다. 따라서 모든 레벨이 꽉 차있고 마지막 레벨은 왼쪽부터 순서대로 채워져 있다. 최대 힙은 각 노드의 값이 그 작식 노드의 값보다 크거나 같고 최소 힙은 각 노드의 값이 그 자식 노드의 값보다 작거나 같다. 힙은 효율적인 삽입 , 삭제, 최대,최솟값 검색으 제공하는 자료구조이다. 

Hash table
해시 테이블은 키와 값의 한쌍을 효율적으로 저장하고 검색하기 위한 데이터 구조이다. 해시 테이블은 해시 함수를 사용하여 키를 해시값으로 변환하고, 이 해시값을 인덱스로 사용하여 값을 저장한다. 평균적으로 탐색에 걸리는 시간 복잡도는 O(log n)으로 우수하며 배열을사용하여 데이터를 저장하므로 메모리 사용이 효율적이다. 단 해시 값이 같을 수 도 있기 때문에 이러한 충돌 처리가 필요하고 이 해시 값을 만들어 내는 해시 함수의 성능에 따라 해시 테이블의 성능이 크게 달라진다. 

Graph
그래프는 객체 간의 관게를 나타내기 위해 사용되는 비선형 데이터 구조이다. 노드간을 연결하는 간선이 방향을 갖지 않는 무방향 그래프, 간선이 방향을 가지는 방향 그래프, 간선에 가중치가 부여된 가중치 그래프 등 다양한 종류가 있다. 그래프의 표현 방법으로 인접 행렬 방법이 있다.

B-Tree
m차 B트리는 자식 노드가 m개를 갖고 있는 균형 이진 트리이다. 데이터베이스 뿐만 아니라 파일 시스템에서 대규모 데이터를 효율적으로 관리하기 위해 자주 사용되는 특히 디스크 IO를 최소화하는데 최적화 되어있다.

Splay Tree
스플레이 트리는 자가 균형 이진 탐색 트리로 최근에 접근한 노들르 빠르게 다시 접근할 수 있도록 재구성하는 특성을 가지고 있다. 트리에 삽입 삭제 검색 연사을 할 때마다 해당 노드를 트리의 루트로 이동시키는 "Splaying" 작업을 수행한다.

AVL Tree
AVL 트리는 자가 균형 이진 탐색 트리의 일종으로 모든 노드의 높이를 추적하여 트리의 균형을 유지하는 데이터구조이다. 해당 트리는 모든 노드에서 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이가 1을 넘지 않도록 보장한다. 이 덕분에 삽입, 삭제, 검색의 시간 복잡도가 항상 O(log n)이다.

Trie
트라이는 효율적인 문자열 검색을 위해 설계된 트리 기반 자료구조이다. 각 노드는 문자열의 문자 하나를저장하며 트리의 경로는 문자열을 나타낸다. 트라이는 문자열을 저장하고 검색하는데 매우 효율적이며, 사전과 같은 응용프로그래에서 유용하다. 문자열 검색의 시간 복잡도가 O(log n)이고 접두사로 시작하는 문자열을 빠르게 검색한다. 삽입 및 삭제 연산이 복잡해 자료 구조를 구현하는데 어렵다.

